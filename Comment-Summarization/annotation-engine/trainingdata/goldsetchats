T181 0 u_Covar : Worth noting PrintWriter will truncate the filesize to zero if the file already exists
T181 0 u_leonbloy : PrintWriter can be (and often is) used|COMMA| but is not (conceptually) the right class for the job. From the docs: "PrintWriter prints formatted representations of objects to a text-output stream. " Bozho's answer is more correct|COMMA| though it looks cumbersome (you can always wrap it in some utility method).
T184 0 u_adesh_singh : will it print the html file as well?
T184 0 u_JBA : @adeshsingh no one ever tried out so faar|COMMA| be the first one!
T182 0 u_Marlon_Abeykoon : So where will the textfile will be created after the app is build and used in another PC since we have not given the path?
T182 0 u_Michael : @MarlonAbeykoon Good question. The answer is that it will create the text file in the working directory. The working directory is whatever directory you execute your program from. For example|COMMA| if you execute your program from the command line|COMMA| then the working directory will be whatever directory you are "in" at that moment (on Linux|COMMA| type "pwd" to see the current working directory). Or|COMMA| if I double-click a JAR file on my desktop to run it|COMMA| then the working directory will be the desktop.
T181 0 u_Rondo : If you want to append and not truncate u can replace PrintWriter with FileWriter: FileWriter(new File ("the-file-name.txt")|COMMA| true).. one trade-off is FileWriter assumes default character encoding and buffer sizes
T185 0 u_kamoroso94 : The syntax for declaring the byte array is incorrect. Should be byte[] data = ....
T183 0 u_Thierry : writer.close() should be in a finally block
T181 0 u_Apollys_supports_Monica : Why is it bad practice to use PrintWriter for this job? Does it perform more slowly?
T181 0 u_ : @Apollys PrintWriter swallows exceptions: stackoverflow.com/a/1747092/4678667
TS 0 u_lokesh : I would suggest to use File.createNewFile() method to create and verify file creation success. It returns a boolean value : true if the file is created successfully. I don't like waiting for exceptions to tell something has failed. Only after file has been created and you have verified it|COMMA| start writing data into it. It can save many bytes. Ref
T186 0 u_Bathsheba : In short then|COMMA| Java intentionally allows it: the "bug" is in the OP's IDE?
T186 0 u_Aaron_Digulla : @Bathsheba: It's more in the heads of people. People don't try to understand how Java parsing works|COMMA| so IDEs sometimes display the code in a wrong way. In the example above|COMMA| the comment should end with \u000d and the part after it should have code highlights.
T187 0 u_Aaron_Digulla : Another common mistake is to paste Windows paths in the code like // C:\user\... which leads to a compile error since \user isn't a valid Unicode escape sequence.
TT 0 u_Reg : I understand introduction of unicode characters|COMMA| but not so much why it is allowed in comments?
T188 0 u_bluelDe : In eclipse the Code after \u000d is highlighted partially. After pressing Ctrl+Shift+F the character is replaced with new line and rest of line is wrapped
T189 0 u_TheLostMind : So.. this is related to how the compiler parses the source-code file?. This problem can't be reproduced when we use block comments instead of single line comments
TT 0 u_aioobe : @Reg|COMMA| there are many features of the language that doesn't make sense in conjunction with other features of the language. In this case|COMMA| the language designers put the unicode escape handling before the parser|COMMA| and being able to use unicode escapes in commens was simply a (possibly unfortunate) side effect.
TT 0 u_Gregor_Ra&#253;man : While I agree with the answer from @aioobe that the source code is valid and the problem is rather in the IDE (and the source code highlighter on StackOverflow)|COMMA| please note that there is another "problem" with the code. The CR character entered as unicode escape sequence is interpreted as a correct start of a new line|COMMA| but the line number is not incremented.
T188 0 u_aioobe : @UmaKanth|COMMA| // comments are skipped all the way to the next new-line character. \u000d is interpreted as a new-line character.
T189 0 u_Taemyr : @TheLostMind If I understand the answer correctly you should be able to reproduce this with block comments as well. \u002A/ should end the comment.
T189 0 u_ : @Taemyr wow|COMMA| \u002A/ is really evil|COMMA| eclipse utterly fails to parse it. Put code between /*\u002A/ and /\u002a*/ and it's completely hidden as comment. Found this as bug 3533
T190 0 u_R.._GitHub_STOP_HELPING_ICE : Note that this could have been avoided completely if the language specification had forbidden using \u notation to represent anything representable in ASCII.
T190 0 u_Ben : @r good point|COMMA| well made. At the very least this should be a Level 1 Compiler Warning.
T190 0 u_Mooing_Duck : @R..: That would make it so that if you're developing on a computer that doesn't use ASCII|COMMA| then there are many characters you can't type in|COMMA| such as IBM Mainframes that use EBCDIC|COMMA| which doesn't have curly braces.
T190 0 u_R.._GitHub_STOP_HELPING_ICE : @TBohne: Do you actually have in mind such a character?
T190 0 u_Mooing_Duck : @R..: Yes|COMMA| curly braces. {}
T190 0 u_R.._GitHub_STOP_HELPING_ICE : @TBohne: Wikipedia claims they're at positions C0 and D0 in EBCDIC. It seems pretty ridiculous to expect programmers to use \u escapes for something as ubiquitous as braces...
T190 0 u_Mooing_Duck : @R.: A quick glance shows you're right. But it also contains "Portability is hindered by a lack of many symbols commonly used in programming and in network communications|COMMA| such as the curly braces." and "It exists in at least six mutually incompatible versions". I assume it must be a different version.
T190 0 u_supercat : @R..: One wouldn't have to forbid everything in ASCII if one were to specify that the first pass of compilation is subdivision into lines|COMMA| and any new-line characters that get introduced after that will be processed as-is|COMMA| such that string st="Hello\u000D\u000Athere" would generate a twelve-character string containing a carriage return and a new-line.
TT 0 u_Jean-Fran&#231;ois_Savard : If ever anyone is skeptic and want to test the hello world program|COMMA| the class should be named "Ugly.java". There is other funny thing that may be caused by this... For example|COMMA| insert LRM character will allow you to compile code such as for (char câ€® = 1; câ€® > 0; câ€®++)
TT 0 u_Jean-Fran&#231;ois_Savard : @biziclop Can we call it comment of the day even if it was posted 8 days ago ? :/
T191 0 u_Supuhstar : How efficient is this?
T191 0 u_Trevor_Brown : Worth a read: jaxenter.com/â€¦ tl;dr - streams could be performant or not|COMMA| it depends on what you're doing with them and the constraints of the problem (isn't this always the answer? lol)
T191 0 u_Marcin_Zukowski : Yeah|COMMA| it's a risky solution from the performance point of view. It might be fast|COMMA| but I wouldn't bet my application's performance on it ;)
T192 0 u_Will_Hardwick-Smith : Additionally|COMMA| if a or b are arrays of primitive types|COMMA| their streams will need to be .boxed() so they are of type Stream rather than e.g. IntStream which cannot be passed as a parameter to Stream.concat.
T192 0 u_Holger : @Will Hardwick-Smith: no|COMMA| you only have to pick the right stream class|COMMA| e.g. if a and b are int[]|COMMA| use int[] both = IntStream.concat(Arrays.stream(a)|COMMA| Arrays.stream(b)).toArray();
T191 0 u_Lii : @Supuhstar: It is probably not as fast as System.arrayCopy. But not particularly slow either. You probably have to do this a very many times with huge arrays in really performance sensitive contexts for the execution time difference to matter.
T191 0 u_Sina_Madani : I wonder which is faster and more memory efficient: the concat method or flatMap? Or are they the same under the hood?
T195 0 u_Dave_L. : The latter solution is nice because it can be used for more than 2 arrays unlike most (if not all) the other answers.
T191 0 u_Holger : @SinaMadani with all known implementations|COMMA| the variant using concat will be faster and need less memory|COMMA| because it can predict the resulting array size beforehand and will create and fill only one array. In contrast|COMMA| the flatMap based solution will have to use a resizable buffer internally|COMMA| with at least one final copying step.
T194 0 u_Artsiom_Chapialiou : Is it possible to make it works for generic type (like in the answer above)? Something like T[] both = Stream.of(a|COMMA| b).flatMap(Stream::of).toArray(T[]::new); Looks like T[]::new isn't allowed cause of type erasure...
T194 0 u_Lii : @ArtsiomChapialiou: You can|COMMA| but it's not so pretty. You have to use reflection to create the array|COMMA| and thus get an unchecked cast. I added that to the solution text.
T196 0 u_ : This answer is more correct than try it because current behavior is not the same as guaranteed behavior.
T197 0 u_ : This question comes into play during Joshua Bloch's chapter on object equality in Effective Java - amazon.com/Effective-Java-Edition-Joshua-Bloch/dp/0321356683
T197 0 u_Andy_Thomas : Specifically|COMMA| in Item 8|COMMA| he notes that in equals() methods|COMMA| one instanceof operator serves two purposes - it verifies that the argument is both non-null and of the correct type. "...[S]o you don't need a separate null check."
T198 0 u_Ben_Thurley : I don't see them ever changing this. It can only return true or false so how can can it ever be true for a null reference to be an instanceof anything?
T198 0 u_Andy_Thomas : @BenThurley - Java's instanceof operator was part of Java 1.0|COMMA| released almost 20 years ago. Changing the behavior now in a way that would break existing code is unlikely|COMMA| absent some benefit that outweighs that huge cost. Twenty years ago|COMMA| maybe there could have been arguments for returning true iff the argument could be cast|COMMA| or throwing an exception for a null argument. But those definitions would have required separate null checks.
T198 0 u_Ben_Thurley : Exactly my point. It's true that current behaviour is not the same as guaranteed behaviour but in this case I think it's pretty well guaranteed.
T198 0 u_Andy_Thomas : @BenThurley - The behavior is guaranteed by Java specifications past and present. I think Luke's point addresses the limitations of experimentation in determining the guaranteed behavior of the present.
T199 0 u_GabrielBB : Why the compiler let you do this: "null instance of Class" lol. I mean|COMMA| if it is a hardcoded null|COMMA| it doesn't make sense to even ask it
T199 0 u_Holger : @GabrielBB thatâ€™s like writing with a red pen on a red paper. Even if it makes no sense|COMMA| itâ€™s possible due to the general possibility to combine an arbitrary pen with an arbitrary paper. And implementing a â€œwriting on the same colorâ€ check into a pen would complicate the technology for little to no benefit.
T200 0 u_Stephen_C : See "Additional Notes #1" of my Answer. For a better explanation of this problem.
T200 0 u_kmort : @StephenC Yes|COMMA| your answer is more complete (and of course|COMMA| +1)|COMMA| but this particular answer had the word "package" in it|COMMA| which allowed me to find what I needed fast. And it worked. So +1 Razavi. StephenC|COMMA| yours lacks the simple package example I needed as I am new to Java.
T201 0 u_John : This was exactly my problem. I have been wading through tons of Java doc and this concrete example is what I needed
T202 0 u_M-Razavi : Its better to make 'Runnable JAR File' to execute class file.
T201 0 u_Pixel : Yes|COMMA| concrete example is nice|COMMA| this worked perfectly. I'm sure the main answer is very thorough|COMMA| but it was difficult to see the tree for the forest. Nice one @Razavi
T201 0 u_Spara : I like this shorter and useful answer instead of accepted one!
T203 0 u_Alex_Spurling : This is probably the best solution presented so far. The reason I didn't spot this facility when I first looked at the DecimalFormat class is that it was only introduced in Java 1.6. Unfortunately I'm restricted to using 1.5 but it will be useful to know for the future.
TU 0 u_Martin_Clemens_Bloch : Doesn't work with exponent decimalformats|COMMA| say format("0.0E00"). It will in this example round 0.0155 to 0.0E00 instead of 1.6E-02.
T206 0 u_ : I tried this with: "#.##"|COMMA| rounding HALF_UP. 256.335f -> "256.33" ...(example comes from comments to @asterite's answer).
T204 0 u_Gomino : Please be carefull as DecimalFormat depend on your current Local configuration|COMMA| you may not get a dot as a separator. I personnally prefer Asterite's answer below
T207 0 u_CGK : Also be aware that you should not expect DecimalFormat to be thread-safe. As per Java docs: Decimal formats are generally not synchronized. It is recommended to create separate format instances for each thread. If multiple threads access a format concurrently|COMMA| it must be synchronized externally.
TU 0 u_user4919188 : how do i make it so that it does a proper rounding so it will not round 0.0004 to 0.001
T206 0 u_Thorsten_Niehues : Cannot get this working with HALF_UP: Example DecimalFormat df = new DecimalFormat("0.00"); df.setMaximumFractionDigits(2); df.setRoundingMode(RoundingMode.HALF_UP); df.format(3.775) returns 3.77
T205 0 u_Dawood_ibn_Kareem : It's not too difficult to create cases where this simply doesn't work. I wouldn't use this method if it's important to get the correct result.
T206 0 u_fishinear : @ThorstenNiehues Just because you specify it as 3.775|COMMA| does not mean it has that value internally. Internally it has a binary value|COMMA| and 3.775 cannot be represented exactly as a binary value. So it might have a value corresponding to 3.77499999999 internally. When rounding|COMMA| always add the expected accuracy of the value.
T206 0 u_Thorsten_Niehues : @fishinear THX :)
T210 0 u_digiarnie : Prior to me putting the high number for the threshold|COMMA| I had the settings set up like you said already but it still put in the wild card imports (i.e. I had "use single class import" checked and removed all packages in the "packages to use import with *"...
T210 0 u_duffymo : Working for me. Let me see what else I might have set. Version 9.0.3 for me.
T210 0 u_digiarnie : So if you do 11 imports of classes from the same package the wild card import doesn't kick in? As a test|COMMA| I have my threshold set to 2. If I import something from org.hibernate let's say|COMMA| it will put the import correctly (fully qualified). As soon as I import something else from org.hibernate it will stick in the wild card import|COMMA| which kind of tells me either my version of intellij doesn't behave like yours or the only solution is to put a high threshold so I never run into this issue
T211 0 u_ : If you're using IntelliJ 12 or later then this can be configured under "Code Style" -> "Java" -> "Imports"
T211 0 u_duffymo : Read my answer - see the "Click on the Settings" bit? It's been true since IntelliJ 7. Already been answered for more than three years.
T208 0 u_PotataChipz : In case it saves someone else the confusion: In my enthusiasm for never collapsing imports|COMMA| I put an unreasonably long string of 9's in the 'class count to use...' field|COMMA| and this caused IntelliJ 12 to silently ignore the value. '9999' works fine.
T208 0 u_Stephen_Hartley : Is there really no way to tell Intellij 15 never to use wildcard imports? I mean without specifying a class count??!
T208 0 u_duffymo : Why is adding a class count so oppressive? Why not ask JetBrains for an enhancement if this is so odious?
T208 0 u_MCory : For the record (at least in IntelliJ Ultimate 2016)|COMMA| trying to set the value to an extremely large number of 9's won't work. If you add more than 5 9's|COMMA| the "Apply" button grays itself out and the setting won't take - instead of just not allowing you to only enter 5 9's. I found this out because I was lazy and just wanted to add a bunch of 9's to make sure it would never be close to an issue at all :)
T208 0 u_duffymo : Looks like three nines should be enough. If you need more than a thousand imports I'd say your class should be refactored.
T209 0 u_Glenn_Bech : Can't believe programmes programmed a program for programmers the way this is programmed. This confusing dialog is still not fixed in 2016.3|COMMA| is there a bug for it|COMMA| or somewhere we can vote?
T212 0 u_Paulo_Merson : Interesting enough|COMMA| for Kotlin the option is less confusing: "Use import with '*' when at least [99] names used."
T209 0 u_Thorbj&#248;rn_Ravn_Andersen : @GlennBech Just contact them on the "Submit feedback" entry in the Help menu.
T213 0 u_StealthVice7 : Why is the nio package better? Does it work in the same way? What even is nio?
T213 0 u_Benoit_Vanalderweireldt : It's not fundamentally better and using the standard io package is fine|COMMA| I'm not sure where is your error coming from but having a clean example of file deletion (starting with a .) might be a good starting point.
T214 0 u_StealthVice7 : My program works perfectly fine with all other test files I made|COMMA| but not the .minecraft file.
T215 0 u_ : System.getProperty("user.home") returns the user's desktop on windows. Use System.getProperty("user.home") + "/.." or similar instead.
T215 0 u_StealthVice7 : What does /.. do? And my program was working fine with all other files with the way I had it.
T215 0 u_Benoit_Vanalderweireldt : / is the root path .. means the parent folder so /.. means the parent folder of root which is incorrect
T215 0 u_Majora320 : @BenoitVanalderweireldt Wrong|COMMA| with <somepath> + "/.." it means the parent folder of <somepath>|COMMA| so in this case it would return the parent folder of the desktop.
T215 0 u_ : /.. != '"<somepath>" + "/.."'
T215 0 u_StealthVice7 : Guys I figured out my mistake|COMMA| the folder had other files inside of it|COMMA| so I had to delete the insides before I could delete the folder.
T216 0 u_StealthVice7 : Hey can you guys undownvote my question? I can't post any more.
T217 0 u_Alderath : \+1. Imo|COMMA| this is more constructive than the top voted answer. It comes with two minor downsides though. The PriorityQueue does not support random access. You cannot do peek(elementIndex). So you cannot do e.g. Integer maxVal = prioQueue.peek(prioQueue.size() - 1);. Secondly if you're intending to use the PriorityQueue simply as a sorted list|COMMA| it will sound less intuitive to see PriorityQueue in the code than it would have been to see SortedList|COMMA| if such a data structure existed.
T218 0 u_Alderath : And|COMMA| after looking at the other question which someone linked in the comments|COMMA| another big disadvantage is that the iterator of PriorityQueue is not guaranteed to return elements in any specific order. So|COMMA| unless I am overlooking something|COMMA| the only way to e.g. print all objects in the PriorityQueue in order is to repeatedly poll() the queue until it is empty. To me|COMMA| this feels borderline retarted. To print the objects in a PriorityQueue twice|COMMA| you'd first have to copy the PriorityQueue and then poll() all objects from the original PriorityQueue and then pol()l all objects from the copy.
T218 0 u_Spoike : Hmm... looks like you're right Alderath. You can't use the iterator of PriorityQueue to get the elements in expected order. Looks like I have to edit my answer.
TV 0 u_bestsss : Sorted list is implemented via tree|COMMA| otherwise it's just way too costy
T219 0 u_bestsss : Priority queue is just a heap|COMMA| you can access only the top|COMMA| imo it does not belong to the answer of the question.
T220 0 u_Mike_&#39;Pomax&#39;_Kamermans : Also worth noting is that Collections.sort() even lets you define the compare function that is used to sort|COMMA| by using a Comparator object.
T221 0 u_user2223059 : I would argue that there is a need for some kind of sorted|COMMA| indexed collection. I'm working on an application|COMMA| and I need a data collection that is accessible via an index number|COMMA| but maintains a very specific order. I don't want to have to use sort() or comparators all the time. So yeah|COMMA| I'm probably going to create a custom collection that just inherits from Collection|COMMA| rather than list|COMMA| that fulfills this function.
TV 0 u_Caitlin : The TreeMultiset allows for multiples in a really weird way. If you have two objects that have the same key|COMMA| instead of actually inserting all of the objects into the Multiset|COMMA| it just keeps track of the count that match that key. This is fine if you are using primitives. But if you are using objects|COMMA| and plan on using other pieces of the object|COMMA| it won't return the objects expected.
TV 0 u_juanmf : @Spoike ` because the add methods should ensure that the element will reside in the index that the user specifies` actually|COMMA|it adds at the end|COMMA| you can specify index in a Map|COMMA| with put(). Am I confused?
TV 0 u_Spoike : @juanmf The key (or index) for a Map is not the same thing as the index for a List. Using put() there is no way for sure that putting something in a lower number and something in a higher number will come in the order you want when you iterate on the entrySet of the map (i.e. unless you sort the entrySet by the key).
TV 0 u_Torque : A huge downside to all of these suggestions is the missing .sub*-function that SourtedMap and SortedSet provide|COMMA| and that at least in my experience is the most needed feature.
TV 0 u_Marcono1234 : @Spoike|COMMA| the own implementation of a SortedList can be written more efficiently. Since a random access list is used (ArrayList) and you know that it is already sorted before adding a new item|COMMA| you can use Collections.binarySearch to get the index where the new item should be inserted.
T225 0 u_rmeador : You don't need to create a class to pass by reference in java (though that would certainly work). You can use the Integer class|COMMA| which is part of the standard library|COMMA| and it even has the benefit of being auto-boxed to and from int almost transparently.
T225 0 u_ILMTitan : @rmeador Integer is immutable|COMMA| so you still couldn't change its value. AtomicInteger|COMMA| however|COMMA| is mutable.
T225 0 u_Dan_Tao : @rmeador: I'm asking because I honestly don't know|COMMA| not to challenge you: how would this work|COMMA| what you're suggesting? What I mean is|COMMA| how can you assign a new value to x from within a method|COMMA| even if it is boxed as an Integer? (Is the Integer type not immutable?) I know that in .NET|COMMA| using C# for example|COMMA| you could box an int as object but you still wouldn't be able to assign a new value to the variable holding that int from within a method|COMMA| unless it were passed as a ref parameter.
T225 0 u_rmeador : @Dan Tao: yeah|COMMA| as @ILMTitan points out|COMMA| it's immutable... I forgot that little detail. The suggestion of AtomicInteger seems reasonable|COMMA| but I don't think you get autoboxing with that class.
T222 0 u_axtavt : @Dan: By the way|COMMA| x in your last example must be declared volatile|COMMA| otherwise it's an undefined behaviour and seeing 1s is implementation specific.
T222 0 u_Dan_Tao : @axtavt: Good point -- I actually discovered this myself after last updating my answer when I changed the code only slightly and saw different behavior (all 0s|COMMA| no 1s). I've updated the answer to include the volatile keyword so that the program's behavior is defined.
T224 0 u_ : simple answer: operator precedence of ++ before =. See cppreference.com/wiki/operator_precedence The "infinite loop" part of title is misleading.
T224 0 u_Dan_Tao : @burkestar: I don't think that link is quite appropriate in this case|COMMA| since it's a Java question and (unless I'm mistaken) the behavior is actually undefined in C++.
T223 0 u_Tom_Brito : Something to say about my last comment on the question?: It's very strange that in C language the behavior is different. Maybe in C it first read the value and then|COMMA| later|COMMA| it increments|COMMA| while in Java it increments then return the old value..
T223 0 u_detly : @Tom Brito - in C it's not defined... the ++ could be done before or after assignment. Practically speaking|COMMA| there might a compiler that does the same thing as Java|COMMA| but you wouldn't want to bet on it.
T226 0 u_Jason_C : This is a very verbose way of saying the right side of an assignment expression is evaluated first.
T224 0 u_ : @burkestar Operator precedence is irrelevant here because (x = x)++ isn't legal. And the "infinite loop" part of the title is a fact; it's not at all "misleading".
T227 0 u_jaxad0127 : Just to note|COMMA| main could be a keyword that is only usable as a name for a static method with an appropriate signature (or whatever). Note that super class calls use super in a way that makes it look like an identifier: super(foo); and super.foo|COMMA| but super IS a keyword (and before generics were added|COMMA| this was the only way to use it (that I can remember)).
T227 0 u_davidxxx : @jaxad0127 Interesting point but I don't agree completely. Actually it IS not and in the future it could probably not be for still compatibility reasons. If you defined main as a keyword in a new version of java|COMMA| it means that any code that uses main as method name (or any member names) will not compile any longer. The usage of super in generics doesn't have any side effect in existing code as generics didn't exist at this time.
T227 0 u_jaxad0127 : I just meant that it COULD have been done as a keyword. Just because it looks like an identifier|COMMA| doesn't mean it has to be.
T227 0 u_GeroldBroser_reinstates_Monica : @jaxad0127 Without going too deep into the JLS and for the two cases you mention I think it can be said that super is a special expression: It represents a reference to a Class object to be used with the object's constructor and its members.
T228 0 u_AJPerez : I would argue that main is still a better identifier than java1234. Using it for a "regular" method would be misleading|COMMA| but I'd have no problem naming a variable main|COMMA| if it's actually the main something in my method. java1234 is just awful|COMMA| names should be descriptive...
T229 0 u_jpmc26 : About the question|COMMA| is main a good identifier? It depends. I probably wouldn't bat an eye at a variable named main if the function I was looking at did something with water main data. I'd throw up if I ever saw java1234 in production code (and pray there were not 1233 other variables with the prefix java).
T227 0 u_Holger : @jaxad0127 main could have been defined to be a keyword|COMMA| it could still become a keyword|COMMA| just like _ stopped to be a legal identifier|COMMA| however|COMMA| it is not and this was a deliberate decision. The Java designers decided that|COMMA| e.g. goto and const are keywords|COMMA| to prevent their use as misleading identifiers|COMMA| but main does not require such special treatment.
T228 0 u_davidxxx : @AJPerez I completely agree. But well both are bad. You could notice that I added main as variable name but I didn't quote it in things that we don't want (not the hazard). But I will remove it to be consistent.
T233 0 u_serg : Looks nice and simple|COMMA| only I have feeling that shutdown here is used not for what it was designed (or it is fine?).
TW 0 u_cletus : It's a common pattern. Transient threadpools like the above are good for several reasons and I pretty much always prefer them to persistent threadpools where a lot more can go wrong or at least it can be harder to figure out. The above is really straightforward which is why I like it.
T233 0 u_matt_b : this is exactly what shutdown / awaitTermination are meant for
T231 0 u_sjlee : It is a good pattern if this task handling is a one-time event. If this is done repeatedly during the same runtime|COMMA| however|COMMA| it is not optimal|COMMA| as you would create and tear down threads repeatedly every time it is executed.
T235 0 u_è±¡å˜‰é“ : This pattern is incomplete: Some unsubmitted tasks may be never executed.
T235 0 u_inanutshellus : @Kejia It is not incomplete... Think about it this way: Your main thread is spawning off subthreads in a loop. When it's done adding|COMMA| you run this code. You might see output out of order|COMMA| but all of your tasks will have been spun off. Thanks @Cletus!
T230 0 u_Sam_Harwell : I'm looking for any official documentation that Long.MAX_VALUE|COMMA| TimeUnit.NANOSECONDS is equivalent to not having a timeout.
T236 0 u_Brad : @serg is this still considered the best answer over using invokeAll() as proposed by sjlee?
T232 0 u_rogerdpack : I can't believe that you have to use shutdown in order to join on all the current threads (after using shutdown|COMMA| you cannot use the executor again ever). Suggest using list of Future's instead...
TW 0 u_jontejj : As I'm testing this out I found that the executor finishes before all tasks have completed. If I use Thread.sleep(100) before calling shutdown() it works. So I suspect that there may be some timing issues with your code if the time between adding tasks to the shutdown call is too small.
TW 0 u_Nazgul : this wont work if you dont want to shutdown the executor. For a perpetually running batch kind of thing u need to submit jobs and wait for them to finish before jumping ahead. In Such a case a latch or a barrier makes more sense than a shutdown.
T234 0 u_gerrytan : IMO it's probably not a wise thing to NOT have a timeout. There's always a likelihood your task is stuck / deadlocking and the user would wait forever.
TW 0 u_Zero3 : @ashutosh I can't find any documentation on this. It appears to be a method of a Spring library|COMMA| and not plain Java functionality.
T230 0 u_ : @SamHarwell see the java.util.concurrent package documentation under the Timing section: To wait "forever"|COMMA| you can use a value of Long.MAX_VALUE
TW 0 u_ToolmakerSteve : @ashutosh 1) That requires springframework. 2) Doesn't look any simpler to me than shutdown/awaitTermination.
TW 0 u_Praveen_Kumar : Is it better than using infinite loop while checking isTerminated() ?
TW 0 u_Sergio_Bilello : If I don't want to shutdown because I want to keep my executor alive. How can I know the maximum number of pending tasks that could I have there?
T230 0 u_hinneLinks : @SamHarwell TimeUnit.NANOSECONDS and Long.MAX_VALUE equals 106|COMMA|751 Days or 292 years (TimeUnit.NANOSECONDS.toDays(Long.MAX_VALUE);)|COMMA| that should be enough|COMMA| or use some of the bigger TimeUnits.
TW 0 u_eli-bd : When sizing thread pools|COMMA| it is often useful to base the size on the number of logical cores in the machine running the application. In Java|COMMA| you can get that value by calling Runtime.getRuntime().availableProcessors(). In this case|COMMA| it would be Math.min(4|COMMA| Runtime.getRuntime().availableProcessors());
TW 0 u_Jobs : executor.shutdown(); is stopping my program !!
TW 0 u_Mobigital : Java apis are pretty terrible. Thank you for this insight.
TW 0 u_gaurav : @cletus is awaitTermination() necessary after shutdown()?
T238 0 u_Ulrich_Schmidt : Well|COMMA| this effectively means that any Function can always be used as a Consumer|COMMA| right? I wasn't aware of this design choice|COMMA| so thanks for pointing this out. Still|COMMA| why then are Function Lambdas like s -> s not allowed as Consumer arguments?
T238 0 u_Czyzby : Well|COMMA| there's always the Java typing issue|COMMA| so you can't pass a constructed Function as Consumer or cast/assign it to a Consumer variable. It still uses the same old Java typing mechanism - you can think of lambdas as anonymous classes|COMMA| except with prettier syntax and different internals. (I won't go into details|COMMA| but chances are that they do not compile into the same exact bytecode.) However|COMMA| any method that could construct a Function<A|COMMA| B> (that consumes type A)|COMMA| could be used to construct a Consumer<A>.
T238 0 u_Czyzby : About the s -> s - my guess is that if you explicitly define a new lambda without referencing an existing method|COMMA| you have to follow its exact method signature. In this case|COMMA| Consumer<String> does not return anything|COMMA| so you cannot just end the lambda with a line that basically stands for return s;. s -> s.toString() (which would pretty have the same result) should work|COMMA| as the method would be simply invoked and its result (s) would be ignored.
T238 0 u_Ulrich_Schmidt : It does work indeed! Amazing! s -> s triggers a compiler error "Void methods cannot return a value" but s -> s.toString() is accepted. I still don't understand the difference between these two Lambda expressions.
T238 0 u_Czyzby : s -> s is an equivalent of s -> { return s; }|COMMA| which fails to compile|COMMA| as Consumer method cannot return a value. s -> s.toString() might seem to "do" the same thing|COMMA| but it actually is an equivalent of s -> { s.toString(); }|COMMA| which simply invokes a method|COMMA| but does not return anything. So - in the first example|COMMA| you're trying to return a value. In the second|COMMA| you're actually invoking a method and ignoring its result.
T238 0 u_ : I think I understand it now :-) If the target type is a Consumer|COMMA| then s -> s.toString()is interpreted as s -> { s.toString(); }. If the target type is a Function|COMMA| then the same lambda is interpreted as s -> { return s.toString(); }
T238 0 u_Czyzby : Yes|COMMA| that's it. Is there anything you'd like me to add to the original answer or can it be accepted as it is?
T238 0 u_Ulrich_Schmidt : Your original answer is certainly acceptable in light of our discussion. Thanks again for your patience in explaining these things. Type inference does sometimes lead to suprising conclusions!
T237 0 u_Brian_Goetz : Here's the basis for this design decision: Java allows you to call a method and ignore the return value (a method invocation expression as a statement). Since we allow this at the invocation|COMMA| we also allow this when adapting a method to a functional interface whose arguments are compatible but the functional interface is void-returning.
T237 0 u_Brian_Goetz : Note also that we'll do other adaptations (boxing|COMMA| unboxing) to make the shape of the lambda match up with the expected shape of the functional interface. Ignoring a return value is just one of those adaptations.
T239 0 u_Hank_D : A convenient way to adapt a Function<T|COMMA|R> to a Consumer<T|COMMA|R> is to append ::apply to a Function instance; then the Function return type can be ignored like any other method that returns a value|COMMA| e.g. Function<String|COMMA|Integer> f = String::length; Consumer<String> c = f::apply;
T242 0 u_Martin : This has changed now. You can use Java 7 as well. As long as you don't use try with resources.
T240 0 u_Ben_Leggiero : Did Java 8 change the way the bytecode works? If not|COMMA| it should be fine to use any version of Java|COMMA| theoretically|COMMA| as long as it compiles.
T240 0 u_Eng._Samer_T : the correct question is: what if you use new features in java 8 not exists in java 7 to build android app|COMMA| is it ok? to be on safe side follow official instructions.
T240 0 u_ : @BenC.R.Leggiero there's no new bytecode in Java 8|COMMA| but the instructions' meanings and structures were changed stackoverflow.com/questions/28228450/â€¦ stackoverflow.com/questions/16143684/â€¦
TC 0 u_Aleksandr_Dubinsky : Please do not post "Update N" in your answer. Rewrite it to have up-to-date information. Otherwise|COMMA| SO will in a few years be as difficult to get information from as the forums it superseded.
TX 0 u_Neon_Warge : As I understand it|COMMA| It says Android N is supporting Java 8|COMMA| so it means APIs < Android N doesn't have it. Is this correct?
TX 0 u_ : Jack toolchain is now deprecated as per this announcement. Replacement is in the works.
T243 0 u_user239558 : This answer needs to be updated. The first sentence "I think it is too early to say if Java 8 is suitable for Android development" is completely outdated an links to old data. The "Updated" stuff is also very old.
T244 0 u_Guillaume_Husta : Not all Java 7 features are available in Android. Like the package java.nio.file. It will be available in Android O as I understand ?
T241 0 u_Ð®Ñ€Ñ–Ð¹_ÐœÐ°Ð·ÑƒÑ€ÐµÐ²Ð¸Ñ‡ : Answer need to be update. Java 8 will is supported as of Android Studio 3.0 and Gradle Plugin 3.0.
T245 0 u_Federico_Peralta_Schaffner : So maybe this should be reported as a bug?
T245 0 u_Holger : @FedericoPeraltaSchaffner I donâ€™t know whether the behavior matches the specification. I just used the word â€œflawâ€ from the practical point of view. I didnâ€™t have the time to check the specification yet and this part of the spec is one of toughestâ€¦
T245 0 u_JimmyB : I don't think it's a "flaw": Consumer<? super Supplier> would even match Consumer<Object>|COMMA| and Object is not a funtional interface. By downcasting to Supplier you make the potentially-Object an instance of a functional interface again.
T245 0 u_Holger : @JimmyB Consumer<? super Supplierâ€¦> could be a Consumer<Object>|COMMA| but you see at the action variable that the compiler does not assume Consumer<Object>|COMMA| as the lambda expression s -> System.out.println(s.get()) invokes the supplierâ€™s get method without problems. Here|COMMA| the compiler does assume the most specific type which is Consumer<Supplier<? extends String>>. And it could do the same for the invocation of accept. See the last example of my answer which doesnâ€™t have a type cast. These assignments are valid.
T245 0 u_JimmyB : @Holger No|COMMA| your last example does not have an explicit cast. But your supp is not of type ? super Supplier but of type Supplier which amounts to the same as the other example with an explicit cast. When using action its declared type is what matters to the compiler|COMMA| and that type does not guarantee that there's a supplier involved. In other words|COMMA| ? super Supplier means that consumer.accept(new Object()) would be valid w.r.t. generic types. Hence|COMMA| the compiler only knows that some object is required and fails to see how customer::getName should target the non
T245 0 u_ : functional interface type Object.
T245 0 u_JimmyB : By the way|COMMA| ? super X is meant to designate some kind of 'container' for objects of type X|COMMA| i.e. it is guaranteed that I can assign an instance of type X to a given variable (ensures assignability). In the case of the OP this is not needed because he won't be assigning anything to the given supplier reference inside his consumer.
T245 0 u_ : @JimmyB You can not do consumer.accept(new Object()). The declaration Consumer<? super Supplier<? extends String>> action implies that you can assign a Consumer<Object> to action|COMMA| because a Consumer<Object> can also handle Supplier<? extends String> arguments in its accept method. But since it is also possible to assign a Consumer<Supplier<? extends String>> to it|COMMA| as happening implicitly in my examples|COMMA| it would never be valid to pass new Object() to the accept method. The argument to accept must be assignable to Supplier<? extends String>. So why not infer thatâ€¦
T245 0 u_JimmyB : @Holger No|COMMA| the argument to accept must be a super type of Supplier. That's what ? super Supplier declares|COMMA| and that does not make sense in this case. Consumer<Supplier> declares what you intend|COMMA| making only instances of Supplier acceptable.
T245 0 u_Holger : @JimmyB: Apparently|COMMA| you are so convinced of yourself that you didnâ€™t even try it. Since you are only repeating yourself|COMMA| this pointless discussion has to stop here.
T245 0 u_JimmyB : @Holger While I do understand your point|COMMA| obviously the compiler proves both of us wrong: It does not in fact accept new Object() (although the effective declared method becomes accept(Object t))|COMMA| but on the other hand it does not infer the need for a Supplier (because the effective declared method becomes accept(Object t)).
T245 0 u_Holger : @JimmyB: There is no such thing as â€œeffective declared methodâ€. Apparently you are confusing this with type erasure|COMMA| but type erasure has nothing to do with what is valid under the generic type system. As said several times|COMMA| the signature Consumer<? super Type> implies that the accept method requires Type|COMMA| the relevant difference to Consumer<Type> is that the actual implementation may be a consumer of a super type. But in the example of the answer|COMMA| it is not. There|COMMA| it is a Consumer<Supplier<? extends String>>.
T245 0 u_JimmyB : @Holger Yes|COMMA| I am referring to type erasure. And through that|COMMA| Consumer<? super X> gets its accept() as accept(<? super X>) (itself not valid syntax)|COMMA| and that method should accept anything of X or a super type|COMMA| hence when typing eclipse offers me accept(Object t).
T245 0 u_JimmyB : @Holger I think|COMMA| together we can pin down the issue: You are correct in that Consumer<? super X> action says something about which kinds of consumers may be assigned to action; could be Constumer<Object> if one wants. Now|COMMA| if I assigned a Constumer<Object> to action at some point in my program|COMMA| action.accept(...) would accept Object which is not a functional interface. Thus|COMMA| from the declared type of action the compiler cannot infer that the actual instance is restricted to functional interfaces|COMMA| because it might not.
T245 0 u_JimmyB : Btw|COMMA| I just tried once more and my eclipse Neon actually only suggests accept(Supplier<...> t) while Oxygen on my laptop showed accept(Object t).
T245 0 u_Holger : @JimmyB there is no need for the target type to be â€œrestricted to functional interfacesâ€. See|COMMA| whenever there is a variable or parameter of type X|COMMA| X being a functional interface|COMMA| you could also assign Y|COMMA| a subtype of X not being a functional interface. The variable is never â€œrestricted to functional interfacesâ€. And once you have assigned the lambda expression to a variable or parameter of a functional interface type|COMMA| the receiving code could always assign that to a wider type like Object. All that matters is whether the compiler understands what to do before assigning the result.
T245 0 u_Holger : @JimmyB Regarding type erasure|COMMA| when you write|COMMA| e.g. Set<Runnable> l = Collections.singleton(() -> System.out.println("hello"));|COMMA| you are also passing the lambda expression to a method receiving Object under the cover|COMMA| as singleton accepts arbitrary types|COMMA| not even remotely restricted to lambda expression. Itâ€™s only our generic (compile-time) usage|COMMA| i.e. assigning to a Set<Runnable> (which will be just Set after erasure)|COMMA| which determines the lambdaâ€™s target type for the compiler.
T245 0 u_JimmyB : @Holger Not sure I get your point. If X is a functional interface|COMMA| then Y extending X should implicitly be a functional interface too. So whatever I can do on a functional interface X|COMMA| I can do on Y too.
T245 0 u_ : Supplier<String> s = obj::toString; works|COMMA| Object o = obj::toString; doesn't.