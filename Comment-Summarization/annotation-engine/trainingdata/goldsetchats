T1 0 u_Fran&#231;ois_Andrieux : Using the wrong delete isn't the same as freeing memory that was already freed. Keep in mind that delete isn't free. delete does eventually cause memory to be freed but it also ends an object's lifetime and calls the destructor.
T1 0 u_Firefly : And its actually not freeing already freed memory|COMMA| its trying to delete memory which you dont own and/or is nothing to do with table.
T1 0 u_Fran&#231;ois_Andrieux : @TheGoldKnight23 Can you please explain how you came to that conclusion?
T1 0 u_Firefly : delete[] will delete the current pointer then look for the other elements of the array|COMMA| even if they dont exist. Which means that when it is called on a single pointer it goes on a rampage of destruction as it never finds the bounds of the array and it is completely undefined as to what happens at that point
T1 0 u_Fran&#231;ois_Andrieux : @TheGoldKnight23 That is just what might happen when you use the wrong delete. It's Undefined Behavior. No single possible outcome is any more valid than any other. It might work fine sometimes. It might not crash and corrupt a bunch of data. It might even crash before it reaches the delete. It's incorrect to presume how UB will manifest.
T1 0 u_Firefly : Sure|COMMA| but it will definitely cause a deletion of something (possibly many somethings) next to it on the heap and then we have objects of type X being destructed as objects of type A (fun :D). But the above segfault is not caused by freeing already freed memory but by using the wrong delete
T1 0 u_Fran&#231;ois_Andrieux : @TheGoldKnight23 Yes|COMMA| using the wrong delete is a problem that needs to be fixed. No|COMMA| it won't necessarily delete something. It might not even delete table at all! You may be interested in reading about time traveling Undefined Behavior. It's real.
T1 0 u_VHS : @FranÃ§oisAndrieux delete indeed frees up memory pointed to by a pointer (and calls destructor). OP is using the delete array operator instead of the plain delete.
T1 0 u_Fran&#231;ois_Andrieux : @VHS Of course|COMMA| but the problem with using the wrong delete is that it is Undefined Behavior. You can't assume it will be a memory problem. delete is not free. It could just as well crash because it tried to execute a destructor with a bad this. I can fail for all sorts of reasons. Bringing in memory management is an error in this answer.
T1 0 u_VHS : @FranÃ§oisAndrieux|COMMA| I tried to reword my answer. I also read your link to the post about time traveling UB. It appears as if such 'time travel' may occur when the compiler sees a UB statically and optimizes it. However|COMMA| in OP's case|COMMA| a compiler may not be able to detect a UB and therefore|COMMA| the delete[] table instruction would be executed at run time.
T1 0 u_Fran&#231;ois_Andrieux : @VHS Maybe time traveling UB won't occur here but it's just an example to illustrate that UB can do anything. As a c++ developer you are required to not presume what UB will do. It's not because we can't think of a reason it would act a certain way that it never will. There could be any number of other reasons that delete[] isn't reached or that delete[] would not reach the point of freeing memory|COMMA|.
T2 0 u_ : @Jon: Out of curiosity|COMMA| why did they set their clocks back by such a "weird" interval? Anything like an hour would have seemed logical|COMMA| but how come it was 5:52mins?
T2 0 u_ : @Johannes: To make it a more globally normal time zone|COMMA| I believe - the resulting offset is UTC+8. Paris did the same sort of thing in 1911 for example: timeanddate.com/worldclock/clockchange.html?n=195&year=1911
T4 0 u_ : @Jon Do you happen to know if Java/.NET copes with September in 1752? I always used to love showing people cal 9 1752 on unix systems
T4 0 u_ : @Mr Moose: I believe Joda Time will do different things depending on the calendar you pick|COMMA| and Noda Time will when we implement cutover calendars. I don't know about the "native" Java / .NET classes.
T5 0 u_ : Does this mean that|COMMA| somewhere in the Java date libraries|COMMA| there's logic handling this very edge case (and every other bizarre edge case)?
T5 0 u_ : @yahelc: Nope - there's just general time zone code|COMMA| which handles all kinds of historical time zone transitions.
T5 0 u_ : @yahelc|COMMA| to elaborate: time zone changes are basically a small set of different possible parameterized events. The code implements this set of events|COMMA| and a timezone database supplies a list of events and parameters for each timezone. By the way|COMMA| this timezone database can be updated independently of the JRE itself: oracle.com/technetwork/java/javase/tzupdater-readme-136440.html
T3 0 u_ : So why the heck was Shanghai 5 minutes out of wack in the first place?
T3 0 u_ : @Charles: Lots of places were had less conventional offsets back then. In some countries|COMMA| different towns each had their own offset to be as close to geographically correct as possible.
T7 0 u_ : I understand the reasoning behind it|COMMA| and why it's implemented like this. I personally think the result should be 'undetermined' at best. The way it's implemented now is as if the first occurrences of 23:54:08-23:59:59 never happened. 1 and 353 would both be a correct answer. Technically 2 different timezone's are subtracted which doesn't feel like correct behavior.
T7 0 u_ : @It'sme...Alex: No|COMMA| there's only one time zone here - with two different UTC offsets. A better API would allow you to determine which instant you meant when parsing an ambiguous local time|COMMA| of course :)
T7 0 u_ : @Jon Skeet: ok|COMMA| two different UTC offsets :-) ... But you understand what I mean. The implementation in java (and most likely other libraries as well) is a bit poor
T7 0 u_ : @It'sme...Alex: Well java.util.Calendar and java.util.Date are certainly poor in a number of ways. In Noda Time|COMMA| when you convert a LocalDateTime to a ZonedDateTime|COMMA| you have to give an indication of how you want to handle ambiguous or skipped instants.
T9 0 u_ : Is there a complete listing of all such time corrections that have been done in all of history?
T8 0 u_ : @JonSkeet If this answer is correct|COMMA| then it might be wise to add it to your answer too|COMMA| that way it's super up to date
T8 0 u_ : @DanTemple: That answer isn't really correct - the time zone database changed the transition time slightly|COMMA| but if you edit the original program appropriately|COMMA| you'll still see a discontinuity.
T6 0 u_ : I now see why Tom Scott says to just not do this. youtube.com/watch?v=-5wpm-gesOY
T6 0 u_ : Tom Scott also has a video on leap seconds @BenC.R.Leggiero: youtube.com/watch?v=Uqjg8Kk1HXo. (This one is from Tom Scott's own YouTube channel|COMMA| not from Computerphile.)
T8 0 u_ : @Jon Skeet|COMMA| I am not able to understand the difference. You have both times from the same time zone|COMMA| if you add or subtract time to a time zone|COMMA| both times must get affected. Then difference should be only one second. Can you please explain with numbers?
T8 0 u_ : @GopsAB: What do you mean by "both times from the same time zone"? Ignore Shanghai for the moment - do you live in a time zone that observes daylight saving time? If so|COMMA| what time does it change? That's a good way of seeing local time change by a different amount from UTC...]
T8 0 u_ : @JonSkeet Yes|COMMA| I meant time1 and time2 in the program are from the same time zone. Isn't?
T8 0 u_ : @GopsAB: Yes|COMMA| but I don't think that means what you think it means. "Same time zone" doesn't mean "same UTC offset". For example|COMMA| I'm in the time zone identified as "Europe/London". Once a year|COMMA| our local time jumps forward by an hour. Once a year|COMMA| our local time falls back by an hour. In both cases|COMMA| two universal times which are one second apart end up having local times which are much more than a second apart.
T8 0 u_ : @GopsAB: It's not true for local times|COMMA| because local times go forward or back quite often|COMMA| usually due to DST. Again - do you live in a culture with daylight saving time? And what do you mean by "both times will get changed"? It's really not clear what's confusing you.
T8 0 u_ : I am from India|COMMA| No DST used in India. What I understood the implementation is something like an array structure|COMMA| where reducing all the elements by a time will not change the arithmetic operations. To be more clear|COMMA| a = [1|COMMA|2|COMMA|3|COMMA|4|COMMA|5]|COMMA| a[1]-a[2] is 1. reduce a by 1|COMMA|a will be [0|COMMA|1|COMMA|2|COMMA|3|COMMA|4] |COMMA| again a[1]-a[0] gives the same answer. I hope it clears my understanding.
T11 0 u_Mox : So it's byRef in regards to objects and byVal in regards to primitives?
T11 0 u_user1767316 : @mox please read: Objects are not passed by reference|COMMA| this is a ledgend: String a=new String("unchanged");
T11 0 u_ : public void changeit(String changeit){changit = "changed";} changeIt(a); assert(a.equals("unchanged"));
TI 0 u_Loduwijk : This is yet another great example of the fallacy of the "it is not pass by reference" semantics argument. This answer says right in the bold|COMMA| first sentence: "only references are passed." Either a reference is passed|COMMA| or a reference is not passed. You just said yourself that a reference is passed. By saying "it is not passed by reference since a reference is passed but..." you are trying to make a point by mangling English.
TI 0 u_philipxy : @Aaron "Pass by reference" does not mean "pass a value that is a member of a type that is called a 'reference' in Java". The two uses of "reference" mean different things.
TI 0 u_Loduwijk : @philipxy Because of some very arbitrary decision that has been made by a sub-set of the software community. What you describe is an opinion of how "Pass by reference" works|COMMA| not a universally accepted definition. Even if you cite a few computer science books which agree with you|COMMA| that only means that those authors share your opinion. English is English|COMMA| and no matter how much the "pass by reference definition purists" want to argue the point they are merely arguing semantics about a non-universal opinion. Some of the answers here are nit-picky about the subjective definition of a nit.
T10 0 u_zakmck : Quite confusing answer. The reason why you can't change a string object in a method|COMMA| which is passed by reference|COMMA| is that String objects are immutable by design and you can't do things like strParam.setChar ( i|COMMA| newValue ). That said|COMMA| strings|COMMA| as anything else|COMMA| are passed by value and|COMMA| since String is a non-primitive type|COMMA| that value is a reference to the thing that was created with new|COMMA| and you can check this by using String.intern().
T10 0 u_zakmck : Instead|COMMA| You can't change a string via param = "another string" (equivalent to new String ( "another string" ) ) because the reference value of param (which now points to "another string") cannot come back from the method's body. But that's true for any other object|COMMA| the difference is that|COMMA| when the class interface allows for it|COMMA| you can do param.changeMe() and the top level object being referred will change because param is pointing at it|COMMA| despite param's reference value itself (the addressed location|COMMA| in C terms) cannot pop up back from the method.
TI 0 u_David_Rodr&#237;guez_-_dribeas : Forgot to mention insertion costs. In a LinkedList|COMMA| once you have the correct position|COMMA| insertion costs O(1)|COMMA| while in an ArrayList it goes up to O(n) - all elements past the insertion point must be moved.
T15 0 u_Ryan_Cox : Regarding the use of Vector: There really is no need to fall back to Vector. The way to do this is with your preferred List implementation and a call to synchronizedList to give it a synchronized wrapper. See: java.sun.com/docs/books/tutorial/collections/implementations/â€¦
T21 0 u_Alex_Beardsley : Also note that as of Java 6 there's no need to worry about losing performance with a thread-safe class. The JVM is smart enough to optimize those locks away from you if you don't need them.
T18 0 u_Kevin_Brock : Linked list add is not always O(1) [or this should say addLast() is O(1)]. This is only true if done from within a ListIterator. The add methods in Java's LinkList implementation must search through the list if additions are not on the head or tail. So worst case this is O(n/2) (which really is O(n); but I wrote it this way as it searches forward or backward depending on the given index so is only over at most half the list).
T18 0 u_ : @Ken Brock That's add(int|COMMA|E) vs add(E).
T12 0 u_dhblah : why LinkedList get is O(n)|COMMA| if you know the position it's O(1)|COMMA| isn't it?
T12 0 u_Jonathan_Tran : No|COMMA| for a LinkedList|COMMA| get is still O(n) even if you know the position|COMMA| because in order to get to that position|COMMA| the underlying implementation has to walk the linked list's "next" pointers to get to that position's value. There is no such thing as random access. For position 2|COMMA| walking the pointers might be cheap|COMMA| but for position 1 million|COMMA| not so cheap. The point is|COMMA| it's proportional to the position|COMMA| which means it's O(n).
T12 0 u_schmmd : With an ArrayList|COMMA| your memory is close together which can improve performance.
T12 0 u_Kevin : @schmmd Then explain why memory is called Random-access Memory?
T12 0 u_Jonathan_Tran : @Kevin memory is random-access. But how do you know which spot in memory to read? For an array/ArrayList|COMMA| you can calculate the address in memory by multiplying the element size times the position in the array|COMMA| because they're stored contiguously. But for a LinkedList|COMMA| you can't do that. Each element stores the address of the next.
T12 0 u_Kevin : @Johnathan Tran Great comment but|COMMA| my point was that it shouldn't be a difference if 'memory is close together'.
T12 0 u_Jonathan_Tran : @Kevin It may matter that memory is "close together". Hardware will cache contiguous blocks of memory (dynamic RAM) into faster static RAM in the L1 or L2 cache. In theory and most of the time practically|COMMA| memory can be treated as random-access. But in reality|COMMA| reading through memory sequentially will be slightly faster than in random order. For a performance-critical loop|COMMA| this could matter. They call it "spatial locality" or locality of reference.
T14 0 u_jsravn : This answer glossed over the worst aspect of LinkedList - significantly more allocations than an ArrayList. This can increase the constant time significantly compared to an ArrayList. Also|COMMA| Vector is not really thread safe - it must still be safely published due to internal non-guarded state (one of the reasons Vector has been deprecated).
T12 0 u_yingted : In order to get O(1) time for seeking|COMMA| you have to call listIterator(0) and always use that for sequential (forwards or backwards) seeking.
T12 0 u_Geek : @JonathanTran you said removal from a linked list takes O(N) and then you say "LinkedList allows for constant-time insertions or removals" . isn't this contradictory ?
T12 0 u_paulw1128 : @Geek remove from position X is O(N) as the list must be traversed to reach the relevant position before doing the actual remove. Iterator.remove is O(1) because it makes use of the constant-time remove without having to traverse the list (i.e. removing the current element).
T12 0 u_Krzysztof_KrasoÅ„ : remove in ArrayList is O(1) if you remove from the end|COMMA| it's O(n) only if you remove in the middle (so you can implement an efficient stack by using add|COMMA| remove from the end)
T20 0 u_Giovanni_Botta : Worth noting that contains() takes O(n) in both cases.
T19 0 u_supercat : If one wishes to remove many items from an ArrayList on a single pass of an iterator|COMMA| is the total time O(N) or O(N^2)? I know I'd implement it to be the former.
T16 0 u_FlyingGuy : It all really comes down to the size of the L2 cache. ArrayLists are faster then linked list as long as you are withing the size of the L2 cache. As soon as what you are storing exceeds the size of the L2 cache|COMMA| it really does not mater that much|COMMA| go with the linked list.
T16 0 u_Matthias : I think that|COMMA| similarly to ArrayList<E>#remove(int index) being O(n - index)|COMMA| you could also argue that LinkedList<E>#remove(int index) is in fact O(index + 1). To see why|COMMA| consider that removing the first element in a LinkedList could only really be O(1). Who (dis)agrees? [Note that this doesn't mean it is wrong to say that LinkedList<E>#remove(int index) is O(n)|COMMA| because the order of magnitude of index is of course n].
T16 0 u_ : Non locality of data hurts the LinkedList even in the case of iterating over the elements: david-soroko.blogspot.co.uk/2015/06/â€¦
T13 0 u_rndStr : Furthering the discussion of the performance of LinkedList.get|COMMA| the documentation states that "the list will be treversed from the end|COMMA| when the position is beyond half way"|COMMA| so "get" would be O(n/2).
T16 0 u_xenoterracide : having read and I think understand this... I would think LinkedList would be preferred default as I personally thing using get is code smell. I rarely want/need it
T13 0 u_Holger : Thereâ€™s no such thing as O(n/2) or O(n/4). The big O notation tells you how an operation scales with larger n. and an operation needing n/2 steps scales exactly like an operation needing n steps|COMMA| which is the reason why constant summands or factors are removed. O(n/2) and O(n/4) are both just O(n). LinkedList and ArrayList have different constant factors anyway|COMMA| so it wouldnâ€™t make sence to compare a O(n/2) of one with a O(n/4) of the other|COMMA| both just denote linearly scaling operations.
T13 0 u_AdamSkywalker : @Andreas|COMMA| use theta notation if you want to show that average is N/4|COMMA| big O is not made for that
T13 0 u_James_Lawson : It's acceptable to add constants to Big-O/Big-Theta to emphasise an additional operation / explain a particular case. For example|COMMA| when we talk about the complexity of reading from a hash table|COMMA| you'll often see: O(1 + load factor). Yes|COMMA| that 1 means nothing asymptotically|COMMA| but it's useful to emphasise that there is a O(1) lookup followed by O(load factor) to follow any chains for collision hashes. Here|COMMA| we're writing O(n/4) more to explain what "average" case is. Asymptotically|COMMA| the factor makes no difference|COMMA| but it's useful for briefly summarising what "average" means for the operation.
T14 0 u_Mani : guys when i was going through vector's usage and differences i found that though vector synchronizes it is not thread safe. please refer this
T15 0 u_Groostav : I think its important to mention: if your implementing something that is pure on the Stack (aka Deque) abstraction|COMMA| requiring that the performance-critical portions of your work use only push and pop|COMMA| then LinkedList gives you O(1) performance in compact memory without any amortization|COMMA| which sounds pretty good to me.
T23 0 u_Haakon_L&#248;tveit : While this is an excellent answer|COMMA| it seems to me that what you really are saying is that you'd use LinkedList lists to build a large collection of varying size and then iterate over all the elements. Meanwhile|COMMA| ArrayList lists are faster if you need to look up varying positions and not just iterate. (If you need to insert at random places a tree-like or map-like structure may be better so long as its ordered|COMMA| like TreeMap)
T15 0 u_Holger : @Groostav LinkedList is all but â€œcompact memoryâ€. If you need a stack or deque|COMMA| use ArrayDeque which gives you O(1) performance in truly compact memory.
T22 0 u_Ben_Kushigian : This is already covered somewhat above but to make it explicit|COMMA| addLast is O(1) as well which is not obvious when discussing linked lists.
T17 0 u_linuxNoob : What is meant by Iterator.remove() is O(1) for linked list? We still need to create the iterator and iterate over the list right? Shouldn't it be O(n) unless the element to be removed is at the end where the current pointer lies?
T17 0 u_Bill_K : @linuxNoob Iterator.remove() can only operate on the linked list as it's being traversed|COMMA| so it is always O(1). LinkedList.remove() would be O(n) unless it was the first item you were removing.
T17 0 u_linuxNoob : @BillK When you say operating on the linked list as its being traversed|COMMA| it still means traversing through the list one element at a time right? Which means if it's not the current element then I'd have to traverse through the list (potentially unknown number of elements) before I can remove it?
T17 0 u_Bill_K : @linuxNoob Yes. If you are doing an operation (let's say searching for a value) you must traverse the list be it linked or array. If it's a linked list then when you find your target|COMMA| deleting it is O(1)|COMMA| if it's an array list deleting it is O(n). Moreover if you are scanning a list to delete|COMMA| say|COMMA| multiple entries with a certain trait then your operation becomes O(n) for a linked list and O(n^2) for an array list. I once "Fixed" an operation (Insertion sort) taking 6 hours down to seconds by JUST replacing an arraylist with a linked list. (then fixed it better with a sorted set)
T17 0 u_Eitanos30 : @Bill K|COMMA| why did you say that iterate over both linked list and array list cost constant time? Isnâ€™t it O(n) since it is the cost for iterating over all the elements?
T17 0 u_Bill_K : @Eitanos30 Iterating over either list is not constant|COMMA| it's O(n)|COMMA| however deleting a single element when you are in the middle of iterating over it is O(1) for a linked list and O(n) for an ArrayList. If you look at the entire operation of removing "n" elements from a list in a single pass|COMMA| it's O(n) for a linked list and O(n^2) for an ArrayList
T17 0 u_Eitanos30 : @Bill K|COMMA| I understand|COMMA| but you wrote in your answer the following sentence: "Iterating over either kind of List is practically equally cheap. (Iterating over an ArrayList is technically faster|COMMA| but unless you're doing something really performance-sensitive|COMMA| you shouldn't worry about this -- they're both constants.)". What did you mean when saying constant here?
T17 0 u_Bill_K : @Eitanos30 Sorry|COMMA| not my answer. It's CW and I don't think I ever contributed to it except for a couple comments. Since it's CW I suggest you go in and edit it.
T17 0 u_ : @Bill K|COMMA| sorry how can i edit it?
T17 0 u_Bill_K : @Eitanos30 There should be a share/edit/flag link under the post. It looks like you have sufficient rep to edit a CW (I think the limit is 100|COMMA| but this question is high activity so they might change it.). I think what he meant|COMMA| by the way|COMMA| is that the increase is linear (constant) as the list grows... but you are right that it's not completely clear.
T17 0 u_ : @Bikl K thanks. I will delete it
T24 0 u_andygavin : Useful if you don't know the API perhaps|COMMA| but if you are having to test private methods in this manner there is something up with your design. As another poster says unit testing should test the class's contract: if the contract is too broad and instantiates too much of the system then the design should be addressed.
T27 0 u_Rick_Minerich : Very useful. Using this it is important to keep in mind that it would fail badly if tests were run post obfuscation.
T27 0 u_Cem_Catikkas : True... Anything Reflective will fail miserably after obfuscation.
T28 0 u_ : The example code didn't work for me|COMMA| but this made thigs clearer: java2s.com/Tutorial/Java/0125__Reflection/â€¦
T32 0 u_despot : This is all great (I've been doing the same for a long time)|COMMA| but there is one glitch that I am trying to find the solution for. Imagine that u wanna test the exception outcome of the private method. Instead of the method invocation giving u an IllegalArgumentException|COMMA| for example|COMMA| you'll get null Class:java.lang.reflect.InvocationTargetException. Maybe there is a way of covering this|COMMA| but I am not familiar with it. A colegue of mine proposed using powermock for it.
T25 0 u_Michael_Piefel : Much better than using reflection directly would be to use some library for it such as Powermock.
T28 0 u_livefree75 : Thank you "Rob" for the link. My test was failing at the getDeclaredMethod() call because I wasn't passing it the parameter arguments.
T32 0 u_ : @despot: According to the doc|COMMA| you should be able to retrieve the original exception via getTargetException() or getCause().
T26 0 u_Thorbj&#248;rn_Ravn_Andersen : This is why Test Driven Design is helpful. It helps you figure out what needs to be exposed in order to validate behavior.
T33 0 u_Asim_Ghaffar : Here is an example for MyAdder.sum(int|COMMA| int) --- MyAdder object = new MyAdder(); Method method = MyAdder.class.getDeclaredMethod("sum"|COMMA| new Class[] { Integer.TYPE|COMMA| Integer.TYPE }); method.setAccessible(true); Object r = method.invoke(object|COMMA| new Object[] { 1|COMMA| 2 }); Assert.assertEquals(3l|COMMA| ((Integer) r).longValue());
T33 0 u_JBoy : shouldn't that be getClass().getDeclaredMethod() ?
T25 0 u_Josef.B : Though this is the excepted answer|COMMA| I would echo some other answers that say one should use a mocking library for this|COMMA| like Powermock or JMockit.
T36 0 u_Tom&#225;Å¡_Z&#225;lusk&#253; : you can't change private static final variables through reflection is not true - final fields can be changed via trick based on clearing Modifier.FINAL flag bit of the Field.modifiers field (unless cases where forbidden by security manager or primitive is inlined by compiler).
T31 0 u_juanmf : Legacy or not|COMMA| you shouldn't change visibility for testing purposes. +1 to Reflection in any case.
T38 0 u_gKaur : For further details on accessing private methods refer link
T39 0 u_Legna : if you are using ExpectedException|COMMA| keep in mid that exception you might expect will be wrapped by a InvocationTargetException|COMMA| so you should do something like : try { method.invoke(svc|COMMA| request); } catch (InvocationTargetException e) { throw ((Exception)e.getCause()); }
T30 0 u_Rog&#233;rio : It's sad to see such a terribly wrong answer like this get so many upvotes. One should not reduce the accessibility of methods or fields|COMMA| neither access them through Reflection. I have written literally thousands of JUnit/TestNG over many years|COMMA| and I never had to resort to testing private methods directly. Occasionally|COMMA| I had to read a private field (through Reflection)|COMMA| but that was about it. I guess some developers (many|COMMA| apparently) are too lazy to write proper tests (which only call public methods)|COMMA| and prefer to cheat by using Reflection.
T40 0 u_BeUndead : These should really be wrapped in helper methods so you don't have to repeat that every time (and naturally... there are several frameworks that do that already). Also; you can most definitely set private static final variables through reflection. Whether you should or not is another matter.
T26 0 u_Jonathan_Neufeld : No I don't think appealing to TDD is a valid criticism here. Why should a unit test intended to cover a private method be excluded from that encapsulation? If TDD is supposed to tell you to make that method public|COMMA| you're not producing quality code here|COMMA| instead you're appeasing a logical flaw in the language itself.
T26 0 u_mike_rodent : Few of these replies and comments appear to have picked on this: the question could have been about approaches to legacy code|COMMA| except that the OP has included the TDD tag. I don't have a huge amount of TDD experience yet|COMMA| but if you study the "seminal" Growing Obj-Oriented Software Guided by Tests|COMMA| I think it becomes clear: private methods should result from refactoring and only from refactoring. By definition refactoring means that the code has passed the relevant tests. So I think the question is why this TDD tag was included.
T26 0 u_Espen : testing private methods should be done from public members|COMMA| private members that are not invoked directly or indirectly by public members have no value. Unit testing and TDD is not about directly testing every method written|COMMA| it is about testing the behavior of the written code compared to the requirements for writing that code.
T29 0 u_mvreijn : Most purists fail to acknowledge that there are legitimate cases for this. My case: I am writing a plug-in for a (closed source) commercial product. Writing regular unit tests for public methods involves mocking large parts of that product|COMMA| and there are limits to this approach. Being able to test my private methods in the manner described above ensures that 95% of my code has been tested before deployment.
T41 0 u_Max_Heiber : In all the answers and comments that poo-poo testing private methods|COMMA| no one gave a good reason to conflate modularity and access. I like to break my code into small pieces|COMMA| where each of these pieces do one thing. This aids readability and maintainability. Just because something makes sense as its own chunk of code doesn't mean I have to expose it as part of the contract for the class. Am I missing something?
T35 0 u_Daniel : This guys provides a more in-depth explanation youtu.be/agnblS47F18?t=24m23s. Check at 24:23 for a solution similar to the example above.
T34 0 u_ACV : One problem with testing private methods with reflection is that if you delete your method|COMMA| you won't see it in the tests at compile time.
T25 0 u_WesternGun : PowerMock Whitebox reads private fields with reflection. So I think I have my answer: test private internal states with PowerMock|COMMA| or just reflection without the overhead of introducing another independency|COMMA| and private methods: don't test.
T42 0 u_Phlip : if you are having to test private methods in this manner there is something up with your design. Well I'm TDDing an Android app|COMMA| so... yeah.
T27 0 u_MasterJoe2 : @RickMinerich - Beginner here. what is obfuscation ?
T43 0 u_MasterJoe2 : @CemCatikkas - I am not asking for any guarantees here. Is Manifold's Jailbreak library reliable enough to be considered for use in commercial software products ? I don't know if it is just an obscure project which is likely to be abandoned in the near future.
T44 0 u_Aman_Arora : They why the output shows different values every time i run it ? I am running on the same machine
T44 0 u_Philipp_Sander : basicly yes. a computer is a working machine and has more or less stuff to do
T46 0 u_Aman_Arora : in the catch(Error e)|COMMA| call other functions|COMMA| If stack is full|COMMA| how it is working?
T47 0 u_Aman_Arora : check the edit please.
T45 0 u_Aman_Arora : Please check the second code . Its not terminating. How it id getting stack to print ?
T45 0 u_Philipp_Sander : it prints the stack|COMMA| because the programm is still running (in an unstable condition). it is not terminating because calling b() in b() is an endless loop ;)
T48 0 u_lance-java : I think the poster doesn't want the file packed inside a jar and wants it in a directory where it can be tweaked without unzipping & zipping again
T48 0 u_VHS : I would tweak my answer if OP confirms that's what he needs.
T49 0 u_mike01010 : @VHS - your answer is closest to what i a want|COMMA| in particular|COMMA| Ans 2.2. Yes lance|COMMA| i want it externally. So i specified the entry in build.gradle as you indicated|COMMA| and i see now that when i do a gradle build|COMMA| it creates a /my_app1/build/resources/main folder. I am still not able to read this with the code i have above however. the error is: "java.io.FileNotFoundException: \config.dev.properties (The system cannot find the path specified)"
T50 0 u_mike01010 : @VHS|COMMA| I am debugging this through eclipse after building it. Wondering if i have to let eclipse know where the resource files are for a given project?
T50 0 u_VHS : @mike01010|COMMA| if you are debugging it through Eclipse|COMMA| the relative paths are all relative to the project folder - the folder which has thesrc folder. So if your build folder is at the same level as src|COMMA| you can use build/resources/main/config.dev.properties.
T50 0 u_mike01010 : @VHS|COMMA| that works|COMMA| but i don't think that code is deployable|COMMA| since there won't be a 'build' folder when deployed. would be nice if the relative path works for both debugging in eclipse as well as runtime
T50 0 u_VHS : @mike01010|COMMA| I understand your concern. That's why people recommend reading files from classpath instead of from a relative path. If a resource file is on classpath|COMMA| you don't need to specify any path regardless of whether the run time is within eclipse or outside.
T50 0 u_mike01010 : @VHS can you point me how to do that. i actually did try renaming the config folder to 'resources' and using ClassLoader.class.getResourceAsStream|COMMA| to no avail. Also|COMMA| does this method allow us to change config entries without having to re-build and re-deploy?
T50 0 u_ : See if this helps.
T50 0 u_mike01010 : @VHS thanks|COMMA| seems like that will compile the config into the jar. not an option for us. We'd like to change values in the config at run-time. will try to figure out best way to do this
T52 0 u_Michael : Thanks @IAdapter. Note that you should always do a compile before hand because it will just put whatever is in "target/classes" in the JAR. This will ensure that the JAR includes any changes you recently made to the source code. So|COMMA| you should do something like: mvn clean compile assembly:single.
T53 0 u_Duncan_Jones : I've edited the question to include the phase binding. I removed the deprecated assembly goal|COMMA| because no-one needs to know about that.
TA 0 u_Sahil_Dave : I've associated the assembly:single goal with the package phase in my project's pom.xml|COMMA| but it works only when I do a mvn assembly:single from the command line.
TA 0 u_Prashant_Vaidyanathan : Is here any way I can direct the <mainClass> to a class under the test directory? I have a main class under org.core (the directory structure exists under main and test) but maven only includes compiled classes from main and not test.
TA 0 u_ : Can we use this metod for java fx jar. Our the default ant jar task is better. But i am facing issues of dependencies with ant jar task.look my Question stackoverflow.com/questions/25915793/â€¦
T55 0 u_pitchblack408 : I see that this doesn't add the jars to the uber jar|COMMA| instead this just adds all the class files to the jar.
T51 0 u_maxivis : Tip: you can also add the element <appendAssemblyId>false</appendAssemblyId> into the configuration to avoid the annoying "-jar-with-dependencies" suffix in the name
T52 0 u_prayagupd : forget compile and you are screwed.
TA 0 u_user3774109 : maven assembly plugin could introduce some issues because could override some dependencies|COMMA| so I cannot tell you to use it! Use the maven Shade plugin instead which works very nice for us. We spent some days to found that the maven assembly plugin overrides some dependencies which break application jar. Have a look there : mkyong.com/maven/create-a-fat-jar-file-maven-shade-plugin
TA 0 u_Niklas_R. : 8 levels of wrapping is insane overdoing it
TA 0 u_Raffi_Khatchadourian : @maxivis Doing this seems to work but generates some warnings.
T54 0 u_parlad : what if i don't have main method or class|COMMA| i just need some random java file to be jar?
T54 0 u_ : @parladneupane leave out the <archive> ...</archive> portion
TA 0 u_user10201743 : He do not asked to use plugings|COMMA| maven should be able compile with dependencies itself without strange commands and plugings
TA 0 u_Adowrath : @user10201743 Just to give a little context: Everything in Maven is a plugin. The compiler? maven-compiler-plugin. Tests? maven-surefire-plugin. These two|COMMA| including the assembly|COMMA| are official maven plugins|COMMA| so they might as well be considered as part of maven (esp. cause|COMMA| at least now|COMMA| all three of them are in your effective POM by default).
TA 0 u_Richard_Bradley_Smith : I ran into this with the alexa-skills-kit-sdk-for-java which worked well until the instructions to create the WAR barfed in Maven. In 'Developing Your First Skill' it says enter the line command 'mvn org.apache.maven.plugins:maven-assembly-plugin:2.6:assembly -DdescriptorId=jar-with-dependencies package' which does not work. I put the above plug-in in the 'highest POM' (closest to the root file) and ran the line command 'mvn clean compile assembly:single' from that POM (directory) and it worked perfectly.
TA 0 u_Halil_Ä°brahim_OymacÄ± : For example if your main class path is src/main/java/com/example/ui/Main.java|COMMA| you must write like that to pom.xml: <mainClass>com.example.ui.Main</mainClass>.
T57 0 u_Piotr_Findeisen : Actually thread.stop() does not necessarily prevent finally block from being executed.
T56 0 u_Andrzej_Doyle : How about we say that the finally block will be called after the try block|COMMA| and before control passes to the following statements. That's consistent with the try block involving an infinite loop and hence the finally block never actually being invoked.
T56 0 u_dieend : By @andrzejDoyle definition|COMMA| it will return success first before going to finally block. Is that correct?
T56 0 u_Laurent_LA_RIZZA : @dieend: It will decide that the return value will be success|COMMA| executes the finally block|COMMA| then gives back control to the calling function. Nothing will be returned if the finally block throws.
T59 0 u_ruhungry : there is also another case|COMMA| when we use nested try-catch-finally blocks
T60 0 u_Amrish_Pandey : also|COMMA| finally block is not called in case of exception thrown by daemon thread.
T58 0 u_ : But effective java says otherwise. informit.com/articles/article.aspx?p=1216151&seqNum=7
TB 0 u_Mikhail_Krutov : This is rather interesting that finally would be called when one re-throws his exception in catch() as new RuntimeException.
T58 0 u_avmohan : @BinoyBabu - That's about finalizer|COMMA| not finally block
TB 0 u_ : What about Runtime#halt ?
T60 0 u_SusanW : @AmrishPandey "finally block is not called in case of exception thrown by daemon thread" - really?? [Citation Needed]|COMMA| I think?
T60 0 u_ : @SusanW javarevisited.blogspot.in/2012/03/â€¦
T60 0 u_ : @SusanW docs.oracle.com/javase/tutorial/essential/exceptions/â€¦
T60 0 u_SusanW : @AmrishPandey The Oracle page doesn't mention daemons at all. The other (blogger) page discusses a JVM terminating|COMMA| but fails to go on to show any difference vs a non-daemon thread. Reality is: on System.exit completion (incl shutdown hooks) or other termination|COMMA| all threads just die where they are standing whether daemon or not: no finallys get executed either way. The blogger is incorrect where they note this as a difference ... try it yourself.
T60 0 u_Stephen_C : @SusanW - Correct. The reason that the daemon thread is not executing finally in that example is reason 3). It is in an infinite loop. If the loop wasn't there|COMMA| then it could also fail to execute the finally for reason 1). When main method returns (and there are no non-daemon threads) it executes System.exit() ... or the equivalent. Bottom line: daemon threads are NOT an exception to the reasons given by the Answer above.
T60 0 u_Loduwijk : Infinite loop is not really an exception to the "finally will be called when try block finishes" rule. Even with an infinite loop in the try block|COMMA| the finally block still will execute when the try block finishes|COMMA| as usual - the try block just does not finish. This is not a special case.
T60 0 u_Loduwijk : The host system dies; eg. power failure|COMMA| hardware error... is not really an exception to the finally block rule either. That's like "will return 1+1 always return 2?" "Not necessarily; a power loss can stop return 1+1 from returning 2." ... not really a part of the answer. Same thing with #4|COMMA| the kill -9 example; it is sufficient for #4 and #5 both that #2 "JVM crash" is listed|COMMA| which could be worded "JVM terminates abruptly" to better catch all situations.
TB 0 u_ : finally is also executed when a StackOverflowError is thrown.
TB 0 u_D&#225;vid_Horv&#225;th : Java'sSystem.exit(); (like C#'s or PHP's) can be confusing for developers coming from other programming languages. In Python sys.exit() raises a (regular) SystemExit exception that can be catched. In Pascal exit is a regular control statement|COMMA| and finally will be executed too.
TB 0 u_Mike_Hill : @MCEmperor|COMMA| to piggy-back on this|COMMA| although finally is executed even after a StackOverflowError|COMMA| frames added to the stack within a finally block can cause an unexpected additional StackOverflowError|COMMA| leading to the remaining contents of the finally block being skipped. For this reason|COMMA| StackOverflowError errors can be quite dangerous. We recently ran into a difficult issue with semaphores not being released in a finally block for this very reason.
TB 0 u_JugsteR : Q: Does it always? A: Yes|COMMA| except... To me this means the accepted answer should be no. If there is exceptions to always|COMMA| then its no. It may run most of the time. But not always. I am surprised I am one of few to react on this.
TB 0 u_Nishit : Also|COMMA| finally won't be called if the world ends before the execution reaches the finally block...
TB 0 u_Captain_Man : @JugsteR All of the cases when it doesn't is when something crazy happens like someone force killing the process|COMMA| it entering an infinite loop|COMMA| or the power going out. To me|COMMA| if it behaves a certain way except in those most extreme of edge cases it's fine to say "yes always|COMMA| except..." instead of "no". Actually|COMMA| in the case of an infinite loop|COMMA| it would still execute the finally|COMMA| it's just that it never finishes what it's doing before it.
TB 0 u_Anonymous_Coward : If the machine is suspended. If the kernel never again gives the JVM time to execute. There are probably many more edge cases when finally is not executed. This answer gives a good and easy to understand explanation. But it would be easier and more simple to say "If the try block or try-catch block completes then the finally block is executed." The JLS uses this same kind of language.
TB 0 u_anir : Can someone shed more light on last point If finally block is going to be executed by daemon thread and all other non daemon threads exit before finally is called.?
TB 0 u_SusanW : @anir The JVM itself will terminate when the last non-daemon thread terminates (that's the defn of a daemon thread|COMMA| btw: it won't prevent the JVM from exiting). So if your daemon thread had entered the try-block|COMMA| and the last non-daemon terminated|COMMA| then the JVM will exit and all daemons will abruptly vanish.
T61 0 u_Drew_Noakes : Except it's O(N) to create the collection in the first place :)
T62 0 u_Xr. : If it's static|COMMA| it's probably going to be used quite a few times. So|COMMA| the time consumed to initialise the set has good chances of being quite small compared to the cost of a lot of linear searches.
T64 0 u_Tom_Hawtin_-_tackline : Creating then the collection is going to be dominated by code loading time (which is technically O(n) but practically constant).
T64 0 u_Basil_Bourque : @TomHawtin-tackline Why do you say "in particular here we want a set"? What is the advantage of a Set (HashSet) in this case? Why is a "reference array" bad (by "reference array" do you mean an ArrayList backed by an array as generated by a call to Arrays.asList)?
T64 0 u_Tom_Hawtin_-_tackline : @BasilBourque The problem trying to be solved is determining whether a value is within a set of values. A Set is a very good fit. / By "reference array" I mean a Java language array of reference types. Arrays of primitives|COMMA| whilst not great|COMMA| are a bit short of efficient alternatives without some necessary clunky library. A later version of Java could support immutable selfless/value types|COMMA| which would change things.
T63 0 u_nmr : isn't this lookup actually O(log(n))
T63 0 u_Tom_Hawtin_-_tackline : @nmr A TreeSet would be O(log n). HashSets are scaled such that the mean number of elements in a bucket is roughly constant. At least for arrays up to 2^30. There may be affects from|COMMA| say|COMMA| hardware caches which the big-O analysis ignores. Also assumes the hash function is working effectively.
T63 0 u_Thorbj&#248;rn_Ravn_Andersen : you have to iterate the array to create the collection. O(n). You can then argue that amortized or simiar this evens out|COMMA| but you must have an O(n) step somewhere.
TC 0 u_Bill_K : This answer is completely right. The point most of the commenters miss is that if you were placing the objects into a collection in the first place it wouldn't be much more time than creating the array was. Just avoid using arrays unless you are absolutely sure nothing else will do (For performance purposes)|COMMA| using an array because you think it will be faster without testing to see if the collection is actually too slow in the first place is a perfect example of premature optimization.
TC 0 u_Paulo_Oliveira : For me this solution with Set is way more elegant than the accepted answer. Thanks.
TC 0 u_Minn : This doesn't answer the question about the array. You just say "don't use arrays" which is not a solution. Additionally|COMMA| you just say "X is bad" but don't explain why which is always bad for an answer.
T65 0 u_kaya3 : At least in the OpenJDK implementation|COMMA| the four-parameter Set.of method doesn't return a HashSet data structure; for so few elements|COMMA| that would not be efficient. See the code here: hg.openjdk.java.net/jdk9/jdk9/jdk/file/86f19074aad2/src/â€¦
T65 0 u_Tom_Hawtin_-_tackline : @kaya3 Good. Big-O is for sufficiently large (i.e. quite large) n. I believe C# has had some kind of hybrid implementation from day 1|COMMA| or perhaps 2.0.
T66 0 u_gsingh2011 : So I supposed it's not possible to call a super constructor and another constructor of the same class as both need to be the first line?
T66 0 u_Jon_Skeet : @gsingh2011: Indeed. You can only chain to one other constructor.
T66 0 u_Christian_Fries : This has to appear on the first line|COMMA| but you can do calculations in the constructor before it is called: You can use static methods in the arguments of this() on the first line and encapsulate any calculation which has to be performed before the call to the other constructor in that static method. (I have added this as a separate answer).
T66 0 u_Ali : @gsingh2011 I know it's late but as a way around|COMMA| you can call overloaded constructor using this(...) and then in that overloaded constructor|COMMA| you can make a call to base class' constructor using super(...)
T66 0 u_Trikaldarshi : @JonSkeet Yes! we can chain to one other constructor but actually we can have a very long chain
T66 0 u_Jon_Skeet : @Mohit: And why is that a problem? It's really not clear what the context of your comment is...
T66 0 u_Trikaldarshi : no not a problem i just added up to your comment that said "only one other constructor" so for many others create a long chain
T66 0 u_Harshit_Gupta : It is mandatory that if you are using this() or super() they must be the first statement of the constructor and both can not be used in a constructor.
T66 0 u_Francis : @gsingh2011 yes|COMMA| for some reason only a single constructor of a class is allowed.
T66 0 u_Jon_Skeet : @Francis: I assume you mean "you can only chain to one other constructor" - currently your statement makes it sound like you can only have one constructor per class|COMMA| which is clearly not true.
T66 0 u_Francis : @JonSkeet yup I meant chaining to one other constructor only. thanks for the correction and I apologize for my misleading statement.
T66 0 u_Justin_Time_-_Reinstate_Monica : @Francis I'm not sure|COMMA| but I believe the reason is that if the first line of the constructor delegates to another constructor or calls a superclass constructor|COMMA| it actually runs before the object is constructed. C++ has the same limit|COMMA| you can only have one call to a parent class constructor or (as of C++11) one delegation per constructor|COMMA| and no more|COMMA| with both executing before the object is constructed.
T66 0 u_Jon_Skeet : @JustinTime: You'd have to define what you mean by "before the object is constructed" for me to be able to judge the truth of that...
T66 0 u_Justin_Time_-_Reinstate_Monica : @JonSkeet I mean that going from what I know of Java|COMMA| delegation or superclass constructor calls are executed before the object's fields are initialised and it's put into a state where it's considered to be "constructed". Specifically|COMMA| I believe the process is: 1) Run parent class/superclass constructor to initialise inherited portion of the class|COMMA| 2) Initialise instance-specific member variables so the object is valid|COMMA| so member access in the constructor's body won't break anything|COMMA| 3) Execute body of constructor to finish construction. It's considered constructed by the end of step 3.
T66 0 u_Justin_Time_-_Reinstate_Monica : In that regard|COMMA| I believe it works in the same manner as C++ (construct inherited portion|COMMA| initialise object from initialisation list|COMMA| run body of constructor)|COMMA| but with cleaner|COMMA| but less specific|COMMA| syntax (the initialisation list is moved to the top of the constructor's body|COMMA| instead of being after the signature but before the body)|COMMA| with delegation passing the job of actually creating the object to the other constructor|COMMA| and then running any code in the delegating constructor on a valid object after the constructor it delegates to returns. Correct me if I'm wrong.
T66 0 u_Jon_Skeet : @JustinTime: Again|COMMA| it depends on what you mean by "creating" - the object is "created" in that its memory is allocated and the type is set before any constructor bodies are executed. Constructors are initialization rather than creation. In particular|COMMA| the type of the object is its "final" type right from the start - so if you call any virtual methods from constructors|COMMA| you'll get the most-specific override called. I believe this differs from C++.
T66 0 u_Justin_Time_-_Reinstate_Monica : By creating the object|COMMA| I mean allocating memory|COMMA| setting the type|COMMA| and initialising fields|COMMA| so that the object is in a valid|COMMA| usable state (the implicit first step of every constructor)|COMMA| with delegation passing the job of making the object valid & usable onto the constructor that's delegated to. Didn't know that objects don't start as their actual type in C++|COMMA| but it makes sense considering how C++ implicitly chains parent class constructor(s) to construct the inherited portion of a derived class before actually executing the derived class' constructor; I guess I'll have to be wary of that.
T67 0 u_Andrej : I know I am coming late to the comment section|COMMA| but I don't understand why new Foo(1); wouldn't work ?
T67 0 u_Jon_Skeet : @Andrej: That would indeed be "calling one constructor from another" but it wouldn't be doing what the OP wants|COMMA| which is to initialize a single object via multiple constructors|COMMA| one chaining to another. Creating two objects by just creating a separate object within one constructor call isn't the same thing at all.
T68 0 u_koppor : If many constructor parameters are used|COMMA| consider a builder. See Item 2 of "Effective Java" by Joshua Bloch.
T68 0 u_YoYo : The problem with the implementation of the last approach using the factory method|COMMA| newCons|COMMA| is that you are trying to change state of an object|COMMA| using setArg1(...)|COMMA| that should most likely have its fields set as final. As we are trying to keep as much as possible of an object immutable|COMMA| if not completely|COMMA| a builder pattern will address this issue more correctly.
T70 0 u_LordHieros : Wouldn't you rather do :: public Cons() { this(madeUpArg1Value|COMMA|madeUpArg2Value); }
T69 0 u_Rodney_P._Barbati : Initialization should proceed from least to greatest - I would never have a default constructor call up the chain to a multi-parameter constructor. What needs to happen is that all constructors call either the default or a constructor with less parameters.
T69 0 u_Joshua_Taylor : @RodneyP.Barbati It's pretty common in Java for lower-arity constructors to call greater-arity constructors and then do nothing else. if a class K has|COMMA| e.g.|COMMA| two final fields a|COMMA| b|COMMA| then the "general constructor" would be K(A a|COMMA| B b) { this.a = a; this.b = b; }. Then|COMMA| if b has a reasonable default|COMMA| there can be a one-arg constructor K(A a) { this(a|COMMA| DEFAULT_B); }|COMMA| and if there's a default a as well|COMMA| we have a default constructor: K() { this(DEFAULT_A); }. That's a pretty common convention in Java.
T69 0 u_Joshua_Taylor : @RodneyP.Barbati If you have a final field (so that it must be set)|COMMA| then the default constructor would have to set it. If your higher-arity constructors call the default constructor (which would have to be done before anything else)|COMMA| then the higher-arity constructors never have any options to set any of those fields.
T71 0 u_Hong : This one works with Android Studio while the accepted answer does not. Not sure why.
T72 0 u_hooknc : Exactly|COMMA| well put. What behavior are we trying to overwrite in Thread by extending it? I would argue most people are not trying to overwrite any behavior|COMMA| but trying to use behavior of Thread.
T73 0 u_ : As a side comment|COMMA| if you instantiate a Thread and do not call its start() method you are creating a memory leak in Java < 5 (this does not happen with Runnables): stackoverflow.com/questions/107823/â€¦
T74 0 u_user949300 : One minor advantage of Runnable is that|COMMA| if in certain circumstances you don't care about|COMMA| or don't want to use threading|COMMA| and you just want to execute the code|COMMA| you have the option to simply call run(). e.g. (very handwavy) if (numberCores > 4) myExecutor.excute(myRunnable); else myRunnable.run()
T74 0 u_m0skit0 : @user949300 you can also do that with extends Thread and if you don't want threading why would you even implement Runnable...
T75 0 u_brettw : I would also add that by implementing Runnable now rather than extending Thread|COMMA| you make it easy for a future refactor of using thread-pools|COMMA| timers|COMMA| schedulers|COMMA| and Executors.
T75 0 u_8bitjunkie : To paraphrase Sierra and Bates|COMMA| a key benefit of implementing Runnable is that you are architecturally seperating the "job" from the "runner".
T77 0 u_Isaac : Another addition to the "practical terms" bit: a Runnable is|COMMA| really|COMMA| an encapsulation of any bit of code. Under certain circumstances|COMMA| it may be useful to run a Runnable even when not within the context of a new thread.
T74 0 u_lolski : @m0skit0 the point of the code by user949300 is that it uses a conditional to only enable multi-threading when there are enough physical core
T74 0 u_m0skit0 : @lolski My point being you can do that extending Thread or implementing Runnable|COMMA| so really doesn't matter.
T74 0 u_Jon_Skeet : @m0skit0: It doesn't matter if you don't care about your code expressing what you're interested in. Personally I care about that very much. Yes|COMMA| you can extend Thread just to implement Runnable... heck|COMMA| you can pass one Thread instance to the constructor of another Thread instance. That doesn't mean it's a good idea.
T74 0 u_m0skit0 : @JonSkeet Sorry|COMMA| I didn't mean it doesn't matter to extend Thread or implement Runnable|COMMA| I meant that that was not a valid argument for implementing Runnable :)
T74 0 u_Jon_Skeet : @m0skit0: What wasn't a valid argument for implementing Runnable? You implement Runnable if you want to represent "something that can be run" - it doesn't necessarily have to be in a new thread.
T74 0 u_user253751 : Note that sometimes you (conceptually) are creating "runners"|COMMA| not "jobs". E.g. if you're writing a thread pool (for whatever reason).
T76 0 u_homerun : @JonSkeet i'm currently creating a class that handles Threads|COMMA| for example: pastebin.com/QNc8xY46. is it OK|COMMA| or terribly wrong to do so?
T76 0 u_Jon_Skeet : @somefolk: Well it feels terribly wrong to have public methods beginning with _|COMMA| and having both start() and _start() is really confusing... as is having an instance method called _sleep()|COMMA| when there's a static sleep method. Not that your _sleep method actually does anything with the instance anyway. In general|COMMA| this looks like a bad idea to me so far.
TD 0 u_ : The same answer is in official Java tutorials: docs.oracle.com/javase/tutorial/essential/concurrency/â€¦
TD 0 u_Warren_Dew : A thread that performs a specific task "is a" thread in the object oriented Liskov substitution sense|COMMA| so the philosophical argument is invalid. The valid arguments for preferring Runnable are practical|COMMA| and have to do with modularization of code|COMMA| especially in cases where you only want multithreading for performance reasons.
TD 0 u_Small_Legend : I know this is an old post|COMMA| but I feel maybe you could elaborate a little more @JonSkeet give code snippets|COMMA| pros and cons. As I believe some other answers are more worthy!
TD 0 u_Jon_Skeet : @SmallLegend: I don't see any benefit in code snippets here - I've basically explained the philosophical difference. You should generally extend a class if you're planning to change some of the behaviour it implements. When you extend Thread just to override Runnable|COMMA| you're changing behaviour that isn't part of Thread itself.
TD 0 u_Small_Legend : Okay|COMMA| you know best! So generally|COMMA| there are no situations where one would choose Thread over Runnable? @JonSkeet
TD 0 u_Jon_Skeet : @SmallLegend: Well if you were customising the actual threading behaviour you could|COMMA| rather than just "the task that it's going to run". Not sure what custom threading behaviour you would implement|COMMA| admittedly...
TD 0 u_H2ONaCl : I think that composition being philosophically purer is an argument for extending an object. Since this answer is saying implementing Runnable is preferred to extending Thread|COMMA| perhaps composition has nothing to do with the rationale.
TD 0 u_Jon_Skeet : @H2ONaCl No|COMMA| absolutely the opposite. Preferring composition over inheritance speaks against extending anything.
TD 0 u_AV94 : Will there be any difference in the execution times between the two approaches?
TD 0 u_Jon_Skeet : @AV94: Not measurable|COMMA| I expect.
TD 0 u_Lealo : If you make an extend thread that prints out "hello" - and make a class that implements runnable - that prints out "hello"|COMMA| does that mean this is still true: "You're not really specialising the thread's behaviour" ?. I mean is there some mechanical things behind the scenes that make them different - or did Jon Skeet mean that you can potentially write more kind of code in an thread that extendend - and that that therefore have a greater risk of being screwed up with? How would telling an extend thread to print hello be more specializing than telling runnable to print hello? How?
TD 0 u_Jon_Skeet : @Lealo: Implementing an interface isn't specialization... It's just providing the behaviour. The point is to separate the infrastructure involved in running "some code" on different thread|COMMA| and what that code is. They are orthogonal concerns|COMMA| so shouldn't be merged together via inheritance|COMMA| IMO. I suspect if Java were redone from scratch today|COMMA| this wouldn't even be an option.
TD 0 u_Lealo : Can you relate your point to the size of an thread that extends a class - to implementing the runnable interface. The thread class already contains the runnable interface. So I assume it somehow are bigger in size. By using extended thread you need (Thread: runnable interface - extending java.lang.object)|COMMA| but you can take out that runnable interface and use it independently. Also is this not then just as comparing (ice cream) with (ice cream + ice cream hornet)?
TD 0 u_Jon_Skeet : @Lealo: The size is irrelevant to the point here. Yes|COMMA| Thread implements Runnable|COMMA| but that was a design mistake IMO.
TD 0 u_user253751 : @8bitjunkie But what if your "unit of work" is a "runner"? For example the "work unit" done by the threads in a thread pool|COMMA| which pulls other work units off a queue and executes them|COMMA| forever.
T77 0 u_ : For reference|COMMA| the Blah.valueOf("A") method is case sensitive and doesn't tolerate extraneous whitespace|COMMA| thus the alternate solution proposed below by @JosÃ©Mi.
T79 0 u_Kevin_Meredith : @Michael Myers|COMMA| Since this answer is the most voted up by far|COMMA| should I understand that it's good practice to define an enum and its String value to be exactly the same?
T79 0 u_Michael_Myers : @KevinMeredith: If you mean the toString() value|COMMA| no|COMMA| I wouldn't say that. name() will get you the actual defined name of the enum constant unless you override it.
T78 0 u_treesAreEverywhere : What exactly do you mean by "are created at compile time and do not appear in source code." ?
T78 0 u_Ti_Strga : @treesAreEverywhere More specifically|COMMA| those methods are generated (or synthesized) by the compiler. The actual enum Blah {...} definition shouldn't try to declare its own values nor valuesOf. It's like how you can write "AnyTypeName.class" even though you never actually declared a "class" member variable; the compiler makes it all Just Work. (This answer may no longer be useful to you 3 months later|COMMA| but just in case.)
T80 0 u_Bill_K : Great answer--in addition I've found adding a few little helper methods to enums helps a lot... For instance|COMMA| if you create a static map of lower-case entries in the constructor then you can add a method that looks the enum up in a case-insensitive way|COMMA| or converts underbars to spaces so user input like "Second Entry" could map to an enum SECOND_ENTRY.
T82 0 u_nemetroid : Why does @Brett's comment have so many votes? Of course it's case sensitive and doesn't tolerate extraneous whitespace|COMMA| anything else would be insane.
T82 0 u_maaartinus : @nemetroid Not that insane|COMMA| given that whitespace is not allowed in names and that all enum names are uppecase by convention. So a tolerant lookup method is possible as the result stays unique. However|COMMA| users may require something even more tolerant and therefore it's best to provide a canonical strict version (and there are other problems like uppercasing being locale-sensitive and whatever).
T81 0 u_Bex : Upvote|COMMA| but this post would be even better with a mention of Enum::name
T83 0 u_Jon_Skeet : This does jump to directly after the loop. Try it! Yes|COMMA| the label comes before the loop|COMMA| but that's because it's labeling the loop|COMMA| rather than the place you want to exit to. (You can continue with a label too.)
T84 0 u_Evan_Carroll : Perl also does permits this its own label system. I think a lot of languages do -- it hardly surprises me that it is in Java.
T84 0 u_Steve314 : @Evan - that claim is clearly true - in languages that promise that it's true. But Java doesn't make that promise. If a language is in conflict with your assumptions|COMMA| it's possible that it's your assumptions that are at fault. In this case|COMMA| I think you're still partly right - principle of least surprise WRT the many who never heard of (or forgot about) that form of break. Even then|COMMA| exceptions are another better-known exception (sorry). But I'd still be unhappy about this if it wasn't obvious (small loops|COMMA| warning comment if the label/break still aren't visible enough).
TE 0 u_Steve314 : @boutta - Ada has this style of break spelled with an exit <optional-label> when <condition>; statement|COMMA| and it has a goto|COMMA| so you can put the label either end of the loop. IIRC|COMMA| goto is much more frowned on than the exit version though. Even for exit|COMMA| some people will beat you with a pretty big stick for using a "hidden goto"|COMMA| but if you use a blatant goto...
TE 0 u_Krishnabhadra : Well one Jon skeet answer I don't like much|COMMA| as I don't want to go through a code like this with all those labels.. But upvoted since it is allowed in the language..
T87 0 u_JWiley : JonSkeet or @BGR Why are break labels not ok? Or why do you prefer the other way?
T87 0 u_Jon_Skeet : @JWiley: I usually find it's easier to read a method which returns from the middle of code.
T87 0 u_Bruno_Grieder : @JWiley. Same here; easier to read: when you "hit" return|COMMA| you can stop reading - easier to maintain: when fixing something before the return|COMMA| you do not have to worry for side effects outside of the loop. IMHO|COMMA| returning fast usually leads to more compact|COMMA| simpler code.
TE 0 u_erhun : In Dijkstra's "Goto considered harmful" paper|COMMA| what he specifically objected to was the labels|COMMA| not the goto. He observed that the number of bugs seems to increase with the number of labels in a program|COMMA| and that labels and gotos make programs difficult to analyze.
T85 0 u_Muhammad_Babar : What is outerloop? No type? Even i tried to do same syntax error!
T85 0 u_Jon_Skeet : @MuhammadBabar: outerloop is a label. I don't know exactly what code you tried|COMMA| but the code in my answer compiles and runs just fine.
TE 0 u_Bruce_Wayne : Does this paradigm work for breaking out of a loop inside a switch-case statement that is part of the loop?
TE 0 u_Jon_Skeet : @Bruce: I suspect so|COMMA| but I suggest you just try it.
TE 0 u_Earl_Zedd : @erhun|COMMA| Regarding labels|COMMA| I would think that "break to" or "continue to" would be inherently more readable than "go to"|COMMA| since the places you can break to or continue to are few and straightforward to find.
TE 0 u_Jon_Skeet : @MinhasKamal: Please stop edits with things like putting "EDIT" in bold for no reason|COMMA| and quoting pieces of output. Your proposed edit was no clearer|COMMA| and clearly conflicted with my intended indentation etc.
TE 0 u_angryITguy : break outerloop == "goto" statement. uurgh! I use booleans as an explicit trigger to terminate a loop in the for statement when i have nested loops|COMMA| single point of exit out of an inner loop and then further tests outside of each loop achieve the same thing|COMMA| but IMHO is better for maintainability. Each to their own..
TE 0 u_Ralf_Kleberhoff : It's a matter of readability. And I think the labeled break is perfectly readable|COMMA| it explicitly declares the block it wants to leave|COMMA| so to me it's even clearer than the unlabeled break. Having said that|COMMA| if the nested loops fulfill some purpose that can be expressed with a method name (and doesn't need to pass a dozen of parameters)|COMMA| introduce the method. But I'd definitely prefer the nested loops with labeled break to a method that's named "loop".
T86 0 u_Nisarg_Patil : I have sonarLint plugin installed in my IDE|COMMA| while using break with label|COMMA| sonarLint gives it as a major codeSmell and when I look at the description provided|COMMA| it says Labels are not commonly used in Java|COMMA| and many developers do not understand how they work. Is the reason provided legit?
T86 0 u_Jon_Skeet : @NisargPatil: The reasoning seems sound|COMMA| although I don't think I'd call it a "major code smell". As per the start of my answer though|COMMA| I'd prefer to just put it in a separate method.
TE 0 u_John_McClane : Maybe you meant "put both loops in a different method (or only body of the outer loop in case continue needed instead of break)"?
TE 0 u_Jon_Skeet : @JohnMcClane: It's hard to know exactly what I meant 9 years later|COMMA| but I suspect you're right. Will edit.
T86 0 u_john16384 : @NisargPatil Just because it is in sonarLint doesn't make it a code smell. It just means there was a developer that added this to sonarLint with a personal itch to scratch|COMMA| and it is full of these kinds of rules that only make sense when abused|COMMA| or because some developer has a personal hate crusade against them. Labelled breaks and continues are a very elegant way to describe what you want to do.
TE 0 u_user10762593 : Unlike many commenters|COMMA| I find nothing wrong with this construct. It's often clearer than flag variables. It doesn't to my mind have the problem that Dijkstra's complaint about label proliferation. With 1960s-vintage labels and goto|COMMA| the presence of a label meant control could arrive there from almost anyway. This sort of label is not a jump target|COMMA| it's just naming a statement. I do however find 'break foo' to be a little odd from readability; BLISS had 'leave foo' for this same construct|COMMA| which makes much more sense linguistically speaking: we are leaving the statement named 'foo'.
TE 0 u_Andrew_Robie : Great info|COMMA| but yeah|COMMA| I can definitely see why you and other prefer having the loop in a method and returning instead.
TE 0 u_Neph : While I do like the return solution|COMMA| sometimes the label solution is better because it doesn't interrupt the flow of reading (as a separate method would)|COMMA| e.g. if you've got more code before and especially after the loops. @JonSkeet A suggestion: Add another print directly after the inner loop. This way you can "prove" that the break actually breaks both loops instead of jumping outside the inner loop and only then breaking the outer loop too.
TE 0 u_Jon_Skeet : @Neph: I'd rather not start editing a 10+ year old answer|COMMA| having to rerun it etc. I haven't seen any sign that people need that "proof". The fact that it doesn't show "3 0" seems proof enough to me.
TE 0 u_Neph : @JonSkeet I just ran it to test it and added the extra print because I wasn't sure how the break would work exactly. Not showing "3 0" just means that the inner loop is broken|COMMA| it doesn't proof that it won't run code after the inner loop (so e.g. the extra print I suggested) before that outer loop is broken too. I can provide an edit for code and prints if you'd like.
TE 0 u_Jon_Skeet : @Neph: No|COMMA| I really don't think it's worth adding the extra output.
TI 0 u_Usagi_Miyamoto : The table above is incorrect|COMMA| as even private members can be seen/used by any class/static method in the same source-file.
TI 0 u_niks : The protected member can only be accessed from subclass of same package but not subclass from different package. There should be a correction in above table
T89 0 u_Deepak : I am still not able to differentiate between 'Public' and 'Protected'. And what is 'World' in this answer. Does it mean access out of project folder in a different project & package?? But that is not taking place. Need help on this.
T89 0 u_adprocas : @Deepak|COMMA| World is within your project. If you have a class that is public|COMMA| any other class can instantiate that class. Same as methods. If it is public|COMMA| anyone that uses that class can use that method. Package refers to the "folder" that you are in. So|COMMA| ca.my.package.controllers is different than ca.my.package.models. Public items are accessible outside of those packages|COMMA| but the rest are not. package-private are considered public within the package|COMMA| essentially. Protected means anything that inherits it|COMMA| or within the same package. Private removes all outside access|COMMA| including package.
T89 0 u_adprocas : World is within your project. I should explain further. Libraries are within your project|COMMA| and if you're creating a library|COMMA| they would expose these public classes and methods as well. So|COMMA| saying just within your project is a bit off. "Everything that uses it" is a better description.
T89 0 u_Deepak : @adpro - I tried at my end making methods public and protected but both of these types of methods are accessible outside their primary package and user has to extend the parent class in both the cases which is quite obvious. I am still unsure of the difference. A little bit more explanation or trick might help.
T89 0 u_adprocas : @Deepak|COMMA| if you are extending (inheriting) the class then that class that is inheriting will have access to all public and protected methods and properties. If you instead instantiate that class in another class (not extend) and try to do something like object.protectedMethod() on a protected method|COMMA| you won't be able to unless it is in the same package.
T89 0 u_adprocas : For example|COMMA| if I have MyClass and I'm doing AnotherClass extends MyClass I will have access to all protected and public methods and properties from within AnotherClass. If I do MyClass myClass = new MyClass(); in AnotherClass somewhere - let's say the constructor - I will only have access to the public methods if it is in a different package. Note that if I do = new MyClass() { @Override protected void protectedMethod() { //some logic } }; it appears that I can access protected methods|COMMA| but this kind of the same as extending it|COMMA| but inline instead.
T88 0 u_Dawood_ibn_Kareem : Unfortunately|COMMA| this answer is a gross oversimplification. Reality is a bit more complicated|COMMA| especially when you consider protected (which is actually quite a difficult access modifier to fully understand - most people who think they know what protected means really don't). Also|COMMA| as Bohemian pointed out|COMMA| it doesn't answer the question - it says nothing about when to use each access modifier. In my opinion|COMMA| this answer isn't quite bad enough to downvote|COMMA| but close. But over 4000 upvotes? How did this happen?
T90 0 u_Anatolii_Stepaniuk : Subclass (same package) field is misleading|COMMA| It's better to remove that column. Because it doesn't matter is that a subclass or not.
T88 0 u_Heinzlmaen : @DawoodsaysreinstateMonica It's a great answer|COMMA| it's exactly what most people that find this page are looking for. Also|COMMA| that table is from the official Oracle tutorial. But how about you toss us a link so we can learn what "protected" really means?
TI 0 u_ : Can you provide an example case with specific data where you think Days.daysBetween is incorrect?
TI 0 u_Patrick_M : When you say to use Instant|COMMA| you're not just talking about start.toInstant()|COMMA| are you?
TI 0 u_Alice_Purcell : @PatrickM Yes|COMMA| I was. On reflection|COMMA| it's not clear exactly what constraints this is intended to impose|COMMA| so I'll remove that last sentence. Thanks!
T93 0 u_Sujit_Joshi : @chrispy daysBetween doc says it returns number of WHOLE days. In my case 2 days and 1 hour should return me 3 days. In your example it returns 2 days. Is there a way to achieve this?
T93 0 u_Alice_Purcell : @SujitJoshi I'm afraid I don't understand your question. I suggest posting a full Stack Overflow question and pasting a link here for me :)
T91 0 u_Sylphe : Beware of dates overlapping with a new year! Days between 31 dec 2016 and 5 jan 2017 gives -361 days.
T91 0 u_Alice_Purcell : @Sylphe No|COMMA| it doesn't|COMMA| I just checked. I suspect you typo'd 2017.
T92 0 u_Oleksandr_Albul : What if cast to UTC DateTime withTimeAtStartOfDay is it equivalent ?
T92 0 u_Alice_Purcell : @OleksandrAlbul That will only give you an answer valid in the UTC timezone.
T94 0 u_ : Pedantically|COMMA| new Random(-229985452).nextInt(27) always returns 8.
T94 0 u_roottraveller : @immibis why? i mean Random() should return random number every time|COMMA| not a fix ordered number set?
T94 0 u_ : @rootTraveller For a start|COMMA| new Random() doesn't return a number at all.
T94 0 u_plugwash : @roottraveller "Random" is a deterministic psuedo-random number generator. If you initialise it with a fixed seed it will produce a fixed sequence of numbers.
T95 0 u_Sohit_Gore : Is there a way these seeds are calculated? There must be some logic...or is it just brute force.
T95 0 u_Fund_Monica&#39;s_Lawsuit : @SohitGore Given that Java's default Random isn't cryptographically secure (I'm pretty sure it's a Mersenne Twister|COMMA| but don't quote me on that)|COMMA| it's probably possible to work backwards from "I want these numbers" to "this is the seed I would use". I've done something similar with the standard C linear congruential generator.
T99 0 u_One_Two_Three : Was this something the people who designed Java intentionally did (as an Easter egg?) It's just a bit mind-blowing that you could possibly product the Hello|COMMA| world String|COMMA| which just happens to be the most favourite string in any programming languages.
T97 0 u_Stephen_C : @Vulcan - the javadoc says that the seed is 48 bits. docs.oracle.com/javase/7/docs/api/java/util/Random.html. And besides|COMMA| the actual seeds are 32 bit values.
T96 0 u_Russell_Borogove : Each element of the random number sequence is taken modulo 27|COMMA| and there are 6 elements in each of "hello\0" and "world\0". If you assumed a truly random generator|COMMA| the odds would be 1 in 27^6 (387|COMMA|420|COMMA|489) of getting the sequence you were looking for -- so it's pretty impressive but not quite mind-blowing!
T96 0 u_dan04 : @RussellBorogove: But with those odds|COMMA| and 2^64 possible seeds|COMMA| there are an expected 47.6 billion seed values that give that sequence. It's just a matter of finding one.
T96 0 u_Russell_Borogove : @dan04 -- I wasn't quite willing to make that estimate; depending on the implementation of the PRNG|COMMA| the size of the seed word might not equal the size of the state|COMMA| and sequence paths might not be evenly distributed. But still|COMMA| the odds are definitely good|COMMA| and if you couldn't find a pair you could try again with different casing ("Hello" "World")|COMMA| or using 122-k instead of 96+k|COMMA| or...
T99 0 u_user1020786 : @OneTwoThree It's almost always very important that a random number generator can be predictable when needed|COMMA| as it's very hard to test things otherwise|COMMA| as running the same code twice can produce different results. Using seeds in PRNGs means you can use a specific seed when testing (or at least report the seed so a result can be reproduced)|COMMA| and then later you can use a seed which will change - e.g. new Random() uses a seed taken from the current time.
T98 0 u_Thorbj&#248;rn_Ravn_Andersen : Note that the javadoc does not specify the exact details of the implementation. Hence you cannot rely on this being portable across JVM implementations.
T98 0 u_ : @ThorbjÃ¸rnRavnAndersen The Javadoc specifies that "particular algorithms are specified for the class Random. Java implementations must use all the algorithms shown here for the class Random|COMMA| for the sake of absolute portability of Java code."
TP 0 u_AndaP : Right on|COMMA| in my opinion almost all documentation revolving around beans can't describe the term as concisely as you have. +1
T100 0 u_worldsayshi : Is it required for the members of a bean to also be beans? Seems like a reasonable requirement..
T100 0 u_Viliam_B&#250;r : @worldsayshi - No|COMMA| it's not required. For example a bean can contain a String; and String is not a bean. (String is immutable|COMMA| so you cannot create it by calling an empty constructor and a setter.) It seems reasonable that a Serializable object should have Serializable members|COMMA| unless it somehow serializes them from outside. So no|COMMA| Java bean members do not need to have any aspect of Java beans. Although it is more simple if they are beans|COMMA| too.
T101 0 u_Puce : All properties private is not correct. Properties are inferred from the getters and setters (if there is a method X getFoo() -> the bean has a readable property called "foo"; if there is a method setFoo(X foo) -> the bean has a writeable property called "foo"). Properties can be backed by member fields (but don't have to be) which are usually private.
TI 0 u_Satyabrata_sahoo : I hope for being a Java bean "a class must be Public". And is it really need that it should implement Serializable Interface??
T102 0 u_ncmathsadist : It sounds as if you should not declare state variables final|COMMA| because you have a no-args constructor. Is this right?
T102 0 u_Paul_Wintz : @ncmathsadist|COMMA| yes|COMMA| that must be the case.
TP 0 u_mavili : Thanks a lot! Why did I have to search everywhere to get to this? Why cannot people be as to the point as you have been with your answer?!! Such a hugely un-intuitive term for such a simple standard.
T101 0 u_OzzyTheGiant : @Puce I think that misnomer is due to the fact that in other OOP languages|COMMA| member fields are called properties (JavaScript|COMMA| PHP) or instance variables (Python). People seem to use these terms interchangeably.
T103 0 u_Giorgi_Tsiklauri : That's all very concise|COMMA| clear and nice; however|COMMA| nowadays|COMMA| a lot of people (in courses|COMMA| tutorials|COMMA| or even talks) refer the the @Entity (javax.persistence.entity) as to the Javabean class annotated with @Entity (for ORM mapping).. and.. @Entity classes do not implement java.io.Serializable.. that's what usually confuses me a bit|COMMA| as I'm a very picky and perfectionist type of person. Is @Entity a Javabean or something close to Javabean?
T104 0 u_ : @phonetagger Take a look at this followup question: stackoverflow.com/questions/11276291/â€¦ The Intel Compiler came pretty close to completely getting rid of the outer loop.
TF 0 u_ : @Mysticial How does the train/compiler know that it has enter the wrong path ?
T107 0 u_ : Under the modern C and C++ standards|COMMA| the shifting hack is actually not implementation-defined behavior|COMMA| but undefined behavior! Shifting a 1 in or out of the sign bit of a signed integer is no longer permissible.
T107 0 u_ : @Novelocrat Only half of that is correct. Shifting a 1 into the sign-bit when it is zero is indeed UB. That's because it's signed integer overflow. But shifting a 1 out of the sign-bit is IB. Right-shifting a negative signed integer is IB. You can go into the argument that that C/C++ doesn't require that the top bit be the sign indicator. But implementation details are IB.
TF 0 u_ : @Mystical readability of the 'hack' can be increased by introducing a method. E.g. in java private int sumIfGreaterThan128(int curSum|COMMA| int value). The JIT compiler will inline it at runtime anyway. I guess in other languages there are equal optimizations available.
T106 0 u_ : @Unheilig Using bitwise operations for anything other than legitimate bit manipulation or multiplying/dividing by a variable power-of-two is not something I usually recommend since it's often obfuscating. Nevertheless|COMMA| here's a good reference for bit twiddling hacks: graphics.stanford.edu/~seander/bithacks.html
T106 0 u_ : @Mysticial Thanks so much for the link. It looks promising. I will go though it. One last request. Sorry|COMMA| but please don't mind|COMMA| could you tell me how you could do this int t = (data[c] - 128) >> 31; sum += ~t & data[c]; to replace the original if-condition above?
TF 0 u_ : @obe: Given hierarchical memory structures|COMMA| it's impossible to say what the expense of a cache miss will be. It might miss in L1 and be resolved in slower L2|COMMA| or miss in L3 and be resolved in system memory. However|COMMA| unless for some bizarre reason this cache miss causes memory in a non-resident page to be loaded from disk|COMMA| you have a good point... memory hasn't had access time in the range of milliseconds in about 25-30 years ;)
TF 0 u_ : Would the conditional be faster than the hack if there was no branch prediction? The conditional would be (check) (jump) (add)|COMMA| whereas the hack uses 4 consecutive arithmetic operations
TF 0 u_ : @woojoo666 That would depend on how expensive the 4 operations are with respect to the branch handling logic. So it'll probably vary on a case-by-case basis.
TF 0 u_ : Isn't it possible to execute both branches in parallel and later stop execution of one wrong branch|COMMA| Instead of predicting one branch?
TF 0 u_ : @TuÄŸrul I would assume that for a given particle the chance that it collides with another particle is less than 1%. Then the branch prediction could just always predict no collision and would be >99% correct|COMMA| whether sorted or not. In the end for fast collision check you'll want to use a tree structure anyways.
TF 0 u_ : I wonder why is the branch prediction concept in place|COMMA| what is the use of the (Branch Prediction)concept ? I mean without it we would get definite result with the sorted and unsorted array.
T108 0 u_ : When does branch prediction takes place? When does language will know that array is sorted? I'm thinking of situation of array that looks like: [1|COMMA|2|COMMA|3|COMMA|4|COMMA|5|COMMA|...998|COMMA|999|COMMA|1000|COMMA| 3|COMMA| 10001|COMMA| 10002] ? will this obscure 3 increase running time? Will it be as long as unsorted array?
T108 0 u_ : @FilipBartuzi Branch prediction happens in the processor while it is running the code. The language doesn't know anything. In your example|COMMA| it will still be fast because you're only adding 1 or 2 mispredictions on and around the 3.
TF 0 u_ : @BJHomer I tried it with Clang 3.5: debug sorted 9.3s|COMMA| debug unsorted 24.6s. O2 sorted 5.0s|COMMA| O2 unsorted also 5.0s. So it seems like Clang is able to optimize the loop well. The branchless version from the post took 13s for debug|COMMA| 4.1s for O2|COMMA| with almost no difference between sorted/unsorted.
TF 0 u_ : This may be out of scope of this Q/A|COMMA| but are there modern processors that will continue down both paths a short ways when the branch prediction reports similar odds for each branch? If not|COMMA| why not? It would seem that spare cycles gone into ensuring the branch is ready in time is better than guessing incorrectly or just waiting around.
TF 0 u_ : @SlippD.Thompson Probably not for the reasons I mentioned in an earlier comment..
TF 0 u_ : Rule of thumb for writing code that is efficient on a modern processor: Everything that makes the execution of your program more regular (less uneven) will tend to make it more efficient. The sort in this example has this effect because of branch prediction. Access locality (rather than far-and-wide random accesses) has this effect because of caches.
T105 0 u_ : The grammar in me wants me to think this should read "... victim of branch prediction failure" rather than just "... victim of branch prediction fail."
TF 0 u_ : So in Java's case|COMMA| for example|COMMA| does the branch prediction take place on the processor level or in the java runtime?
TF 0 u_ : GCC has a lot of optimizations that aren't enabled by default|COMMA| among the things it can do:
TF 0 u_ : it can split loops (with -ftree-loop-distribution and -ftree-loop-distribute-patterns)|COMMA| move invariant sections (by default)|COMMA| move invariant conditions out of the loops (with -funswitch-loops|COMMA| but causes duplication)|COMMA| convert conditional jumps to conditional stores or remove them (-ftree-loop-if-convert and -ftree-loop-if-convert-stores). Sadly a lot of these options have unsafe side effects|COMMA| and only do any good improvement to very naively written code.
TF 0 u_ : There is another fact here. The data and temporal locality. When you access the same position many times subsequently|COMMA| its value still in the registers|COMMA| so this is why the loop interchange doubles the performance over the original sorted version.
TF 0 u_ : @Mysticial|COMMA| Is this answer still valid given the processor changes now in 2015/6?
TF 0 u_ : @Sandeep Yes. Processors still have branch prediction. If anything has changed|COMMA| it's the compilers. Nowadays|COMMA| I bet they're more likely to do what ICC and GCC (under -O3) did here - that is|COMMA| remove the branch. Given how high profile this question is|COMMA| it's very possible that compilers have been updated to specifically handle the case in this question. The definitely pay attention to SO. And it happened on this question where GCC was updated within 3 weeks. I don't see why it wouldn't happen here as well.
TF 0 u_ : I just ran the code in VS 2015 and the sorting doesn't improve performance anymore. I measured about 1.1s for 32768 elements and about 11s for 327680 elements (moved to a global variable to prevent a stack overflow) with my Intel Core I5 with 3.6GHz thanks to TurboBoost. I looked to a disassembly and I didn't find any branch except one for terminating the loop - it actually uses instructions like cdq and movlpd which are normally used for floating point operations.
TF 0 u_ : @One-One The prediction is done at the beginning of the pipeline|COMMA| the operation flows through the pipeline and reaches a waiting area for its operands. Once its operands are available|COMMA| the instruction executes and the instruction becomes eligible for retirement (commit to actual state). The retirement of the branch checks whether the guess was correct. If not|COMMA| flush pipeline and restart instruction fetcher at correct instruction. If prediction was correct|COMMA| just keep going. By this time|COMMA| many instructions after the predicted branch have started but have not been committed to state.
TF 0 u_ : Complementing... you can also use something like 'sum += (data[i] > 128) * data[i];'|COMMA| which is still branchless but same accuracy as the one with the branch.
TF 0 u_ : What about the ternary operator? sum += data[i] > 128 ? data[i] : 0
TF 0 u_ : @NicholasHamilton The ternary operator is a branch. Though some compilers (namely MSVC) seem to be better at optimizing them than plain-old if-statements.
TF 0 u_ : Really good explication. If you add this code it become much more faster: for (register unsigned i = 0; i < 100000; ++i) { // Primary loop for (register unsigned c = 0; c < arraySize; ++c) { register int t=(data[c]<<25)>>31; sum += ~t & data[c]; } }
TF 0 u_ : @Mysticial: Thanks for such a nice insight. After going through this came to my mind couple of questions: identify a pattern and follow it this sounds more of artificial intelligence. So is it safe to say modern compilers are equipped with AI algorithms for branch prediction? halt execution and wait until the previous instructions are complete that sounds to me of multiple threads. Does CPU internally breaks code blocks into threads? (One your comment also mentions processor is executing many instructions at the same time). If yes|COMMA| what role does compiler play?
TF 0 u_ : @Atul The Wikipedia article on branch prediction has examples of some branch prediction algorithms. Whether or not you want to call them "AIs" is up to you. For your other question about multiple instructions at the same time|COMMA| it's called Superscalar Execution.
TF 0 u_ : @Mysticial: Thanks! I took some time to go through article(s). What I gather is|COMMA| branch prediction is more about processor architecture|COMMA| no matter what compiler we use (unlike what I was under impression)
TF 0 u_ : I still fail to understand why the compiler has to even predict?! Why does it not just compare the two values with each other and decides then?!
TF 0 u_ : @EdwardBlack It's not the compiler that does the prediction. It's the processor. Secondly|COMMA| the processor can't "just decide" because it's doing many things at the same time. To oversimplify things a bit|COMMA| while the processor is executing the current instruction|COMMA| it's already reading ahead by 20+ instructions and preparing them for execution. If you have a branch|COMMA| the processor needs to decide which side to do this "read ahead". When there's a misprediction|COMMA| everything that has been "read and prepared ahead of time" needs to be thrown away and restarted on the other side.
TF 0 u_ : @EdwardBlack An appropriate analogy for this "read ahead" thing would be airline flight scheduling. Flight schedules are made months ahead of time. But when something unexpected happens (like a storm shutdowns down a major hub)|COMMA| flights get canceled and that schedule goes up in smoke. The result? Massive delays that propagate through to many flights that don't even touch that airport. Of course for a processor|COMMA| the "pre-planning" window is on the order of nano-seconds and up to a few hundred instructions rather than thousands of flights that cover months.
TF 0 u_ : This is a good answer but it should be made clear that it is processor branch prediction that is causing this behaviour. Compilers predict branches too.
TF 0 u_ : As a side note|COMMA| there has been some research done where branch predictors were able to "figure out the pattern of rand()". They had a branch that was basically if( rand.nextInt(100) < 50 ) and correctly predicted something like 99% of the time.
TF 0 u_ : There were a few questions as to why the processor doesn't just execute both branches. One reason is that processors can have as many as 20 predictions in-flight (guessed but not resolved yet). To handle that many you'd need to be executing 2^20 (1048576) different paths at the same time.
TF 0 u_ : @Riley I actually did answer the comments about executing both branches. But it seems that my comment got deleted for some reason.
TF 0 u_ : @Mysticial Was your answer basically the same or is there another reason?
TF 0 u_ : @Riley Same. Exponential resource growth and the fact that prediction is often very accurate.
TF 0 u_ : @Adjit There's no simple answer to that. For the particular case here|COMMA| GCC and ICC can do conditional moves|COMMA| but VS can't. But that will change depending on the code. The example in this question is optimizeable to a conditional move. But not always. Only really simple branches can be optimized this way.
TF 0 u_ : @Adjit No|COMMA| that's way too specific. What to take away is that anything that causes the flow of execution to conditionally change is subject to a performance penalty due to branch misprediction. This includes if-statements|COMMA| loop-conditions|COMMA| switches|COMMA| ternary operators|COMMA| short-circuiting boolean logic|COMMA| calls to function pointers|COMMA| calls to lambdas|COMMA| calls to virtual/polymorphic methods|COMMA| etc... (The last 3 of these aren't related to branch-prediction per se|COMMA| but the same concept applies in that the processor doesn't "know where to go" next.)
TF 0 u_ : @Mysticial is there a particular reason you opted for your implementation (declaring an int) over sum += ~((data[c] - 128) >> 31) & data[c]; ?
TF 0 u_ : @Zze No. That was just the way it turned out when I derived it. The variable being the mask that either enables the value|COMMA| or sets it to zero.
TF 0 u_ : @mysticial Does it mean that it is possible that the result of the program is incorrect because of the prediction? How does it know/validate whether the guessing is correct? Wouldn't that still need to actually compute everything to know the correct result for validation?
TF 0 u_ : @elfan No. Branch prediction does not affect correctness. When the processor runs a set of instructions|COMMA| it must behave "as if" it were running them line-by-line. It can play tricks underneath to make things faster (such as branch prediction)|COMMA| but in the end|COMMA| it still must respect the program as it is written. For your other question|COMMA| the processor will know when a prediction is correct once the branch instruction executes and determines which way it's supposed to go.
TF 0 u_ : @Mysticial|COMMA| does it mean in this case the code will complete in around 2 seconds (instead of 12) if there is no branch prediction|COMMA| and that the extra 10 seconds was because of the overhead of wrong predictions (the train going back)?
TF 0 u_ : @elfan No. As a hypothetical example: If there was no prediction|COMMA| it would always take 10 seconds. With good prediction|COMMA| it would be 2 seconds. With consistently bad prediction|COMMA| it would be 12 seconds. The extra 2 seconds being the overhead of going back. In most cases|COMMA| it will be closer to the 2 seconds|COMMA| so it's a net win.
TF 0 u_ : I see|COMMA| so the 8 seconds was the overhead to stop the train and ask the driver every time. If there was no branch at all|COMMA| and no branch prediction|COMMA| then the code will always take 2 seconds (i.e. similar to the case that the prediction is always correct in a system with branch prediction). Thanks for your great explanation @Mysticial
TF 0 u_ : More simplify way for: int t = (data[c] - 128) >> 31; sum += ~t & data[c]; is char t = data[c] >> 7 ; /* Truncating the 7 bits (equivalent to data[c] >=128 ) */ sum += -t & data[c]; /* -t will be equivalent to -1 if data[c] >= 128*/.
TF 0 u_ : How does this influence (if at all) the evaluation of the complexity of an algorithm?
TF 0 u_ : @njzk2 it doesn't. Complexity is the asymptotical behaviour of the time (or size) of a function when its inputs tends to infinity. Branch prediction failures doesn't change how the curve behaves at infinity|COMMA| it only adds some constant computation time to the branch operation.
TF 0 u_ : I question the efficacy of human minds when it comes to unnecessary overhead such as branch prediction. I just read up on the Wikipedia articleâ€”what smart person invented this so I can smack him upside? Just do two concurrent speculative executions for both branches and then discard the "wrong" branch's speculative execution.
TF 0 u_ : @LinkTheProgrammer I'm not so sure the solution is that simple. Because if it was|COMMA| they'd probably be doing that already. The main problem I see is that modern CPUs will be predicting multiple branches ahead. And that leads to an exponential state explosion if you want to follow them all. The other thing is that running down multiple paths means you'll be wasting a lot execution resources on stuff that will be thrown away. And that probably has implications for power consumption as well.
TF 0 u_ : @Mysticial perhaps|COMMA| but I'm thinking pure latency here. We can worry about power consumption when my $200 laptop stops lagging and people start writing actually efficient code.
TF 0 u_ : There is also __builtin_expect in GCC to help the compiler. See stackoverflow.com/questions/109710/â€¦
TF 0 u_ : sum += ~t & data[c]; The above will be wrong since a & operation will change the bits. What you want is as below a multiplication operation: sum += (~t * data[c]);
TF 0 u_ : I would like to know what patterns can i use to achieve this? Is there anything i could do without properly planning all the time on these small array operations so i can just write code in a fashion that suits for the computer? Is it better to sort the array all the time before an operation? I know its sort of pointless at this level but many things add up very quickly. Also does the same thing applies in other programming languages? Or is it c++ specific?
TF 0 u_ : @Azarus I think you're among a sizable # of people who are getting confused by the sorting aspect. Sorting has nothing to do with branch prediction itself. It just happens to expose the effect of branch prediction in the specific example of this question. So don't go around blindly sorting things thinking it will magically solve everything. Not all illnesses are treated with antibiotics. You need to understand the problem first before you can apply the solution. Otherwise you may end up doing more harm than good. And before you even get to that|COMMA| the rules of premature optimization still apply.
TF 0 u_ : @mystical i am aware of that would be indeed really stupid to sort arrays all the time. The computer would run into branch prediction all the time. But my question was more about what can we use in practice to avoid or reduce its performance issues if theres any in the first place? Is there anything we can do about it? Or its not worth the effort and situations where it really matters are rare?
TF 0 u_ : @Azarus If you're looking for a "best practice"|COMMA| it's in the answer already - "A general rule of thumb is to avoid data-dependent branching in critical loops." But I can't speak for whether it's worth the effort since it depends on the requirements of the application and the available resources to do it.
TF 0 u_ : ok|COMMA| I see your benchmarks|COMMA| but whole branch prediction thing doesn't provide much performance. it introduces more problems than solving it. then why cpu manufactures even bothered integrating such thing in it?
TF 0 u_ : @M.kazemAkhgary Because branch prediction helps in >95% of the cases in real life. The example in this question happens to be that remaining 5%. And even in that 5%|COMMA| the penalty is minimal compared to not predicting at all and always stalling.
TF 0 u_ : I'm afraid your proposed optimisation is flawed: int t = (data[c] - 128) >> 31; has implementation defined behavior: data[c] has int type|COMMA| so data[c] - 128 will be negative for values less than 128. Right shifting a negative value has implementation defined behavior. You can fix this for 2's complement architectures with a simple expression: sum += -(data[c] >= 128) & data[c]; for which many compilers will produce code without jumps. Alternatively|COMMA| given the range of data[c]: sum += -(data[c] >> 7) & data[c];
TF 0 u_ : @chqrlie When you get to this level of optimization|COMMA| implementation-defined behavior is often an acceptable trade-off. Especially since sign-fill right-shift is essentially universal for 2's complement architectures. The real offender here is assuming a 32-bit int. It's been a while|COMMA| but I probably didn't use a solution with a comparison because I had experiences with compilers generating branches for bool -> int conversions. You also can't do that in Java. Anyway|COMMA| that was 5 years ago. I rarely do these hacks anymore since I prefer the SIMD intrinsic route.
TF 0 u_ : @M.kazemAkhgary Short answer is that each core has multiple pipelines. Long answer is that it's a loaded question. Try searching for "superscalar processor". Modern processors can execute around 4 instructions/cycle.
TF 0 u_ : On ARM|COMMA| a (short) conditional is a zero-cost operation|COMMA| because every instruction has a 4-bit conditional field (allowing for 16 different types of conditions on any instruction)|COMMA| so branching can be completely avoided in many cases. (In this case|COMMA| just do the comparison|COMMA| then conditionally accumulate). So on ARM|COMMA| the runtime will be longer for sorted than for unsorted|COMMA| because sorting requires extra work.
TF 0 u_ : Note that this optimization is precisely the cause of Spectre and Meltdown big security vulnerabilities. In short|COMMA| some operations like caching are not actually rollbacked (for performance reasons)|COMMA| which cause some potentially sensitive data to become readable by other processes.
TF 0 u_ : Let me clarify one thing about your analogy with trains: train suffers by making a bad choice|COMMA| because it needs to get back to the branching point on failure (I consider that it's going to be the wrong choice as you see). Does the branch prediction suffer from a bad choice compared to not making any choice and rather waiting? Or is the branch prediction in CPUs beneficial in both cases (making train analogy imprecise)?
TF 0 u_ : @Evusas I'm not a hardware designer|COMMA| so I don't know the answer for sure. But the rollback logic certainly isn't free. Even if the CPU designers managed to completely hide the performance impact of a misprediction roll-back|COMMA| there are still costs in terms of power consumption of the wasted computation. Today's chips are very power optimized and will vary their clock speeds to stay under a power limit. So it's certainly within the realm of possibility that excessive waste of power from mispredictions can indirectly hurt performance.
TF 0 u_ : @TimothÃ©Malahieude or maybe overly optimistic guarantees of OS vendors on process isolation are the cause. Some OSes that do not use the concept of process don't care at all
TF 0 u_ : @Mystical seems to me that the brach pridiction decreases the elapse time that the execution takes but not less CPU time/work is actually done cause the condition need to be checked either way|COMMA| just there are less CPU idle times. Then one can say that if you make milion different jobs|COMMA| the total time to do all of the will be similar with and without branch pridiction. so it optimizes perfomance but not throughput. is this right?
TF 0 u_ : @naviram No it isn't. A CPU's resources can't be redistributed like that. Most of it is use it or lose it. If the CPU is stuck waiting for a branch to unwind (among many other things)|COMMA| its computing resources remain idle. Features like hyperthreading will allow some amount of sharing. But not to the level that you describe where everything is always utilized no matter what happens. Also|COMMA| a branch misprediction involves wasted resources. So in the case you describe where throughput matters and everything can be prefectly redistributed|COMMA| branch prediction would be actively harmful.
TF 0 u_ : I haven't read every comment but while the answer's explanation is good|COMMA| a simpler (and faster!) version for this specific task is sum += data[c] * (data[c] >= 128);. It is better than the posted answer even in unoptimized builds (in optimized builds|COMMA| even the naive version is faster than the posted answer actually|COMMA| a good reminder that micro-optimizing is bad). A comparison doesn't mean a branch. Compiler is clang 9.0.
TF 0 u_ : @Mysticial: You might want to qualify the "avoid data-dependent branching in critical loops" a bit|COMMA| given it's really only valid when the conditional block performs very little work? A little worried someone will take it literally and make some expensive statement unconditional...
TF 0 u_ : Can the train track analogy apply to junctions in the processor's actual electrical circuits?
TF 0 u_ : Is there a definition of a "predict friendly" code available ? Are the following statements "predict equivalent" ? Or is first statement more "predict friendly" than second ? why ? if (a && b)... if (a) if (b)...
TF 0 u_ : after I saw this post|COMMA| I am happy to have chosen to give up my financial career and become a developer in old age
TF 0 u_ : A God among mortals
TF 0 u_ : Congratulations for your record|COMMA| +1 to keep the legend on
TF 0 u_ : @Unheilig re: "could you tell me how you could do this int t = (data[c] - 128) >> 31; sum += ~t & data[c]; to replace the original if-condition above?". Sure. x>>31 returns 0 for all x>=0 and -1 for x<0. ~ inverts the result|COMMA| so ~(x>>31) returns 1 for numbers >=128|COMMA| and therefore the right hand side of the & is returned. Otherwise it returns false and returns 0. There reason >>31 detects sign is because we're dealing with 32 bit signed integers and 1 bit is reserved for sign.
T112 0 u_ : Java does not allow us to 'emulate pass by reference'. The failure of one user to accept an answer is not a huge weakness of the entire site.
T112 0 u_ : Explain what you mean by "java does not allow us to emulate'. As far as the weakness|COMMA| it's a difference in opinion.
T109 0 u_ : Honestly|COMMA| you can simplify this answer by saying Java is pass by value only for primitive types. Everything that inherits from Object is effectively pass by reference|COMMA| where the reference is the pointer you're passing.
T109 0 u_ : @Scuba Steve if that's what you got out of my post|COMMA| I have totally failed to get my message across. Everything in java is ALWAYS pass by value and NEVER pass by reference. When passing an object|COMMA| you're actually passing a reference to that object|COMMA| but THE REFERENCE IS BEING PASSED BY VALUE (i.e. a copy of the reference is passed.) And again|COMMA| this not my personal opinion|COMMA| but true by definition.
T109 0 u_ : That's true for any reference in any language... unless you explicitly passed a reference by reference|COMMA| which generally speaking|COMMA| wouldn't make much sense to do.
T109 0 u_Sanjeev : Not the case. This is true in C|COMMA| Java|COMMA| JavaScript|COMMA| but not true in Pascal (which has "Variable Parameters" the same as reference parameters) and C++ (please see the example I posted)
T109 0 u_Sanjeev : Other examples of pass by reference languages are c#|COMMA| php|COMMA| vb.net|COMMA| and fortran.
T111 0 u_Juan_Mendes : I don't think C++ owns the term "pass by reference". In Java|COMMA| it's very common to say "pass a reference"|COMMA| because when you pass an object|COMMA| you don't copy the object|COMMA| as you could in C++. it is a pointer to a location in memory|COMMA| but yes a new pointer. In C++|COMMA| it's a pointer to a pointer... So|COMMA| I prefer to use other terms and not assume C++ is the standard everyone must follow and understand.
T111 0 u_Sanjeev : @JuanMendes|COMMA| I just used C++ as an example; I could give you examples in other languages. The term "Pass by reference" existed long before C++ existed. It's a textbook term with a very specific definition. And by definition|COMMA| Java is not pass by reference. You can keep using the term in this way if you'd like|COMMA| but your usage will not be consistent with the textbook definition. It's not just a pointer to a pointer. It's a construct provided by the language to allow "Pass By Reference". Please take a close look at my example|COMMA| but please don't take my word for it and look it up for yourself.
T109 0 u_AutomatedMike : Describing java as "pass-by-value" is highly misleading. For non-primitive types Java uses pass by value of the reference. Pass by value implies the value is copied when passed to a method. It is not|COMMA| the reference is copied. What java does is not the same as either pass by value or pass by reference in C++.
T110 0 u_Sanjeev : @AutomatedMike|COMMA| if the reference was being passed-by-reference|COMMA| there wouldn't be a copy of the the reference. It would be as if the argument and parameter were two different names for the same variable. That's the distinction between pass-by-value and pass-by-reference. Please take a look at my c++ example to see what I mean. Another way to look at it is that java does not pass the "Swap Test". Here is a great article which discusses exactly what I mean : javapapers.com/core-java/â€¦. An example Pascal would be more clear. I'll try and post one.
T110 0 u_JÄ™drzej_Dudkiewicz : @AutomatedMike I think that describing Java as "pass-by-reference" is also misleading|COMMA| their reference are nothing more than pointers. As Sanjeev wrote value|COMMA| reference and pointer are textbook terms that have their own meaning regardless of what Java creators use.
T110 0 u_AutomatedMike : @Sanjeev that's why I said "pass by value of the reference" not pass-by-reference or pass-by-value|COMMA| as stated many times both these terms are miss-leading when describing what java does.
T110 0 u_Sanjeev : @AutomatedMike|COMMA| I understand where you're going with that. My point is that we don't need new terminology. Pass-by-value adequately describes what java does. The value of the reference is indeed passed by value in Java.
T110 0 u_Artanis_Zeratul : Java is pass by reference. Or passing the value of a reference in objects. Since in Java everything is an object except for atomic types like int|COMMA| char|COMMA| boolean|COMMA| etc. For people who always says its pass by value I think they making it more complicated rather than simplifying the matter.
T110 0 u_Sanjeev : @ArtanisZeratul the point is subtle|COMMA| but not complicated. Please take a look at the cartoon I posted. I felt it was pretty simple to follow. That Java is Pass-by-value isn't just an opinion. It's true by textbook definition of pass-by-value. Also|COMMA| "people who always say it's pass by value" include computer scientists like James Gosling|COMMA| the creator of Java. Please see the quotes from his book under "Edit 2" in my post.
TP 0 u_newfolder : What a great answer|COMMA| "pass by reference" does not exist in java(and other languages like JS).
T113 0 u_AndrewF : This part of the answer is misleading and should have been changed: "Java is Pass-by-value|COMMA| but allows us to emulate pass be reference by passing a Java reference (i.e. a pointer) by value." -- That doesn't emulate pass-by-reference at all. The closest thing to emulating it would be to pass (a copy of a reference to) some mutable "holder" object|COMMA| e.g.|COMMA| an AtomicReference|COMMA| and the called function would mutate the "holder" to hold a new value. The caller would need to understand that usage; the language would not help.
T113 0 u_Sanjeev : @AndrewF. Yes|COMMA| in a sense|COMMA| you could emulate pass-by-reference even more closes by enclosing the "reference" in a mutable object since this would allow changing the "reference" in the function. But my goal was to explain the origins of passing "reference" or a pointer by value. How closely this emulates PBR is not relevant to my argument.
T113 0 u_AndrewF : I think most of the comments/answers on this question (and this answer itself) have covered well that passing a reference/pointer value is not pass-by-reference by definition and does not exhibit the bidirectional behavior of pass-by-reference. So there is no emulation whatsoever. The rest of the answer gets it right|COMMA| but that one sentence gets it wrong.
T113 0 u_Sanjeev : @AndrewF|COMMA| I'm still not TOTALLY convinced this section is incorrect or misleading|COMMA| but I'm open to the idea that you might have a point and I'm just missing it|COMMA| especially since you're the second person to object. Either way|COMMA| you've convicted me to change it (the first chance I get) because even if that one bullet is historically correct|COMMA| it's a distraction from my core message. Thanks for the feedback.
TG 0 u_Bhanu_Sharma : i found filenotfound exception while i try to read file name with "Ð”Ð¾_ÑÐ²Ð¸Ð´Ð°Ð½Ð¸Ñ" file name(Russian language) i try with FileInputstream but it not cable to read this filename from sdcard.
T114 0 u_Chris.Zou : For android developers|COMMA| seems like android does not come with IOUtils from Apache. So you might consider referring to other answers.
TG 0 u_James : I work in a limited footprint environment|COMMA| so the solution by @PavelRepin below using the java io/util libs makes more sense.
TG 0 u_Esben_Skov_Pedersen : @ChristofferHammarstrÃ¶m totally agree. Even on the same machine if you run java from cmd or from your IDE.
T117 0 u_Donal_Fellows : IOUtils.toString() works very nicely with the Java7 try-with-resources.
TG 0 u_ : maven dependency for commons-io <dependency><groupId>commons-io</groupId><artifactId>commons-io</artifactId><version>2.4</version> </dependency>
TG 0 u_AutonomousApps : For gradle users: compile 'org.apache.commons:commons-io:1.3.2' (I'm having trouble finding the latest version; anyone?)
TG 0 u_ : It' s a worse idea to use 3rd library to load inputstream to string. Try this gist.github.com/XinyueZ/440e015b3a1afb692812
T118 0 u_ : Guava version: CharStreams.toString(new InputStreamReader(stream))
T115 0 u_Shadoninja : This is an incredibly old question at this point (it was asked in 2008). It is worth your time to read through more modern answers. Some use native calls from the Java 8 library.
TC 0 u_codepleb : This answer is heavily outdated and one should be able to mark it as such (sadly this is not possible atm).
TG 0 u_Ilya_Gazman : It turns out that this method is the slowest! Check out my benchmarks here
TG 0 u_Steve_Chambers : In case it helps anyone I've filled in the small gap in the second part of this answer on how to close the stream in this answer.
T116 0 u_Roshan : IOUtils.toString() has long been deprecated. This answer definitely is not the recommended way any more.
T116 0 u_Jean-Fran&#231;ois_Fabre : then edit it to explain why it is deprecated to help future readers.
TG 0 u_ : Check out this handy example of IOUtils.copy: apisonar.com/java-examples/â€¦
T119 0 u_MetroidFan2002 : I disagree with your statements for the DO_NOTHING action. If the find action method cannot find an action|COMMA| then returning null is the right thing to do. You've "found" an action in your code which isn't really found|COMMA| which violates the principle of the method|COMMA| to find a useable action.
T120 0 u_Laplie_Anderson : I agree that null is overused in Java|COMMA| especially with lists. So many apis would be better if they return an empty list/array/collection instead of null. Many times|COMMA| null is used where an exception should be thrown instead. An exception should be thrown if the parser can't parse.
TH 0 u_Thorbj&#248;rn_Ravn_Andersen : I think it should be possible in the source code to specify that null is never returned from method X and that a given parameter should NOT be null and it is an error to pass one.
T121 0 u_Steven_Evers : The latter example here is|COMMA| IIRC|COMMA| the Null Object design pattern.
T123 0 u_DragonBorn : Assertion is good for TESTING. It's dangerous to use on PROD.
T119 0 u_Cshah : I disagree with DO_NOTHING because although it eliminates that null check|COMMA| the resultant behaviour is unexpected. If null is an unexpected input to your method then it is pertinent that your method throws NPE so that the caller is aware and things are logged(A fail fast behaviour). With using DO_NOTHING|COMMA| its like everything passed but the resultant action didnt take place and users will redo the action (resubmitting the form). I agree to return empty lists|COMMA| objects but not nulls as return values but dont agree to the DO_NOTHING illustrated above. But NPE's shouldnt display stacktrace on UI
T119 0 u_Kevin_Brock : @Cshah (and MetroidFan2002). Simple|COMMA| put that into the contract and then it is clear that a non-found returned action will do nothing. If this is important information to the caller|COMMA| then provide a way to discover that it was a non-found action (i.e. provide a method to check if the result was the DO_NOTHING object). Alternatively|COMMA| if action should normally be found then you still should not return null but instead throw an exception specifically indicating that condition - this still results in better code. If desired|COMMA| provide a separate method returning boolean to check if action exists.
T120 0 u_Berlin_Brown : I am defensive in my coding and do the null checks. Especially in a J2EE environment. My thinking is that anything that can be null...could potentially be null at some point. Contractually|COMMA| in most cases I don't want to throw an illegalarg exception or nullpointer because Java shouldn't have null refs in the first place. In most cases|COMMA| I try to find a default return value and fail fast with the default value/expected return value.
T122 0 u_gshauger : Concise does not equal quality code. I'm sorry you think so. Your code hides situations where an error would be advantageous.
T119 0 u_Thorbj&#248;rn_Ravn_Andersen : @MetroidFan|COMMA| if you return a valid Action which doesn't do anything you have a simpler caller without a branch. Branches cause additional complexity|COMMA| and keeping them as few as possible makes for simpler testing.
T119 0 u_MetroidFan2002 : @ThorbjÃ¸rn Ravn Andersen By hiding the possibility that the findAction method may not find an action|COMMA| you've now done logic that|COMMA| while it doesn't break the program|COMMA| may result in undesired effects that aren't found until a much later stage (possibly in production). Depending on if findAction really can be expected to not find anything|COMMA| this is highly undesireable - returning null or throwing an exception|COMMA| like imaginaryboy suggests|COMMA| are better approaches so that they can be explicitly checked for and paths taken to account for the lack of finding an action.
T123 0 u_monksy : Whats the point of using assertions when they only fail for you? Yes you can catch stuff while you're working on it|COMMA| but in production how will they help if you never hear about that in odd situations?
T120 0 u_DarthVader : There is nothing wrong with checking null values|COMMA| and I have seen lot of senior/rockstar developers who check for null values everywhere. Also|COMMA| null checking is one of the cheapest operation in a programming language.
T120 0 u_Eelco : Agreed with DarthVader. I'd argue that not being defensive enough is the junior thing to do. There are very few libraries out there|COMMA| and very few coders in my experience that have the discipline to completely describe their contracts (and that includes whether nulls might be returned/ are acceptable values for arguments)|COMMA| so often there isn't much to trust.
T123 0 u_Sal : @Saj: Why Assertions are only good for testing and dangerous for productive systems? If there is a condition that leads to an error it has to fail also in production. Nevertheless it's important to have some JUnit test or integration test that checks that assertion. Furthermore enable assertions with "-ea"
TH 0 u_Sebastian : In the "compare" code your perspective is being unveiled for the fact that if you have nothing to do when NULL is returned for action then why checking for NULL? You make the code looks uglier than just a checking for a non NULL value. Avoiding coding styles|COMMA| I prefer the way I've seen in some android api code while asking for NULL. They just return if the involved method can't continue working even thought method profile returns void. And if you have to|COMMA| arrange things previous the return statement. Of course|COMMA| you are returning and breaking the normal flow of a high level language.
T123 0 u_ianpojman : assert is unusable for me|COMMA| because it has to be explicitly enabled - I want my assertions to always be enabled. Someone said: "but in production how will they help if you never hear about that in odd situations?" Easy - you get an exact and crystal clear failure as near to the root cause of the problem as possible|COMMA| and can easily patch it with much less effort than reverse engineering the entire system trying to figure out where the failure was. That is why design by contract|COMMA| fail-fast|COMMA| no-null design is the only way to go.... and never use 'assert'|COMMA| use a mechanism that is always enabled....
T119 0 u_Matthew_Kirkley : Instead of the DO_NOTHING action I would probably create a hasAction(userInput) method|COMMA| returning a true or false if there is a valid action for that userInput. Then findAction would return the action or throw an Exception ActionNotFoundException
T123 0 u_FidEliO : although my testing has shown next to no performance impact from assertions. Your assumption is not based on Oracle documentation. It can highly affect performance in type of system that includes real-time computation.
T120 0 u_Jonathan : I agree with MetroidFan2002. he is spot on. returning null can sometimes happen and it is not dirty at all to check for nulls. by all means if you can avoid nulls and always initialise your contracts then you wont need to check nulls
T121 0 u_ : @SnOrfus +1 for mentioning the Null Object design pattern. I learned something here. See en.wikipedia.org/wiki/Null_Object_pattern
T120 0 u_Anders_Lind&#233;n : I never return null so I never check return values for null. I never need to think about which variables that are valid. They all are. I never pass null to a method so I never need any input validation in my methods. If it would feel logical to actually have a method that allows a null parameter to be passed|COMMA| I create two methods instead. Minimizing code duplication by breaking out commons is then important.
T120 0 u_user1050755 : I'm against code bloat and agree with this solution. Explicitly checking for NULLs is an anti-pattern IMHO. The Java way is to throw *NotFound/InvalidAccess etc. exceptions which avoids the necessity for the caller to explicitly handle irregular situations. I even go further: use arg.equals("foo") instead of "foo".equals(arg)|COMMA| or use native types (long instead of Long) to implicitly FORCE NPE. Fortunately|COMMA| when returning a null object|COMMA| the caller can still try to call a method on that null value and force a NPE. :-)))))
T121 0 u_Ryan_Bennetts : Often|COMMA| the behaviour you want to implement if an object is null will be similar no matter where you receive the null object. As others have noted|COMMA| the answer's DO_NOTHING action is|COMMA| in fact|COMMA| The Null Object Pattern (en.wikipedia.org/wiki/Null_Object_pattern) which collects this 'what do we do if it's null?' logic in one place and so reduces duplication. However|COMMA| the Null Object Pattern is really just a more limited version of Martin Fowler's Special Case Pattern: (martinfowler.com/eaaCatalog/specialCase.html) which is great for eliminating checks for values other than null too.
TH 0 u_Ricky_Clarkson : I'd go for Optional/Option or an exception here. Returning null is just poison for your caller; they'll forget to handle it and see a problem far away from the call site.
T119 0 u_Travis_Wilson : @MetroidFan2002: agreed re: DO_NOTHING|COMMA| but not quite. If the find action method cannot find an action|COMMA| then the method didn't do what it said it would do. In that case it should not return. It should throw.
T119 0 u_MetroidFan2002 : @TravisWilson If the method was going to throw something|COMMA| it should throw IllegalArgumentException|COMMA| not NPE|COMMA| because it's explicitly checking for null and doing something with it. IAE would also handle getting non-null input and not being able to find anything for it as well. But|COMMA| nowadays with Java 5+|COMMA| I would throw NPE IFF the method took an enum constant as a parameter|COMMA| since you'd have something (one for each enum constant) or nothing if proper practices with enums were observed.
T120 0 u_MetroidFan2002 : @user1050755 What you are doing with strings is both dangerous and naive. When you do checking against a literal|COMMA| you want to know if that literal matches|COMMA| not if the string is null. The naive way to do that is as you've suggested|COMMA| with a useless null check: if(stringVar != null && stringVar.equals("literal")) But|COMMA| this forces you to directly send in null input for testing coverage|COMMA| resulting in unneeded branches. "".equals(stringVar) will always work regardless. If you know the literal to check on|COMMA| you should always do this - it's the safest|COMMA| easy to read and doesn't do extra conditions.
T119 0 u_grinch : I don't get why everyone is hating the DO_NOTHING. Sure|COMMA| in this example it is minimalistic - but this is a programming language... add in an "isEmptyAction()" method to the class... the point is to ENCODE the state of the objects|COMMA| not return some cryptic-lack-of-a-value that you somehow have to just know to check for... "isEmptyAction()" is an actual API that encodes the fact that an action might be empty/do nothing. Much much much cleaner|COMMA| imo (and many others|COMMA| hence the fact that it is it's own defined design pattern ...)
T119 0 u_Travis_Wilson : @MetroidFan2002: absolutely. NPE is not usually the right thing to throw. Not finding a method is a totally legitimate outcome so it should be something specific that the consumer is required to catch. Maybe it's a result of bad input|COMMA| in which case I like IllegalArgumentException (but am not thrilled that it's a RuntimeException). Also by this rule: if the method says it might return an action that does nothing (say|COMMA| for consumer's convenience)|COMMA| then returning DO_NOTHING is fine.
T120 0 u_dfeuer : Throwing NPE is a very sensible thing to throw when something is null that shouldn't be. By the way|COMMA| you should be careful if you're dealing with concurrency|COMMA| because something that's not null when you check it might be null when you use it.
T120 0 u_UFL1138 : I just added the final two suggestions to the answer -- the try/catch and the more-meaningful default action. @dfeuer I don't think NPE makes sense unless 'someInput' is null. I agree with Travis Wilson that IllegalArgumentException also is not ideal|COMMA| although it's not inappropriate. My suggestion is a custom exception with a meaningful message that can be shown to the user that supplied the bad input.
T121 0 u_Ziggy : @MetroidFan2002 late to the fray. The point with the null object pattern is that you are returning null. The user can still check for a null object|COMMA| by comparing it with the null object. She can also ignore the fact that she got back a null: that's the advantage. If you implement a method|COMMA| and you think null is an OK value to return|COMMA| then the thing you returned (the null) should still obey the API of the thing you promised to return. If it's unacceptable|COMMA| then you should have thrown instead. The user can still decide for herself|COMMA| by checking for the null object and throwing.
T121 0 u_MetroidFan2002 : @Ziggy It's not that I disagree with the null object pattern|COMMA| and I use it all the time. It's that in this particular case|COMMA| the method signature is findAction A DO_NOTHING action|COMMA| by definition|COMMA| is NOT FOUND! That's lying to your user. And having the user have to check for DO_NOTHING violates polymorphism - now not all your instances can be used interchangeably. To put it in perspective|COMMA| let's say the method was BigDecimal findBigDecimal(String whatever) - The Null Object pattern does not work here. Finding something lies to you if zero is returned.
T121 0 u_artbristol : Null Object pattern is more useful than null because sometimes the result isn't used immediately - it could be stored in a field|COMMA| for example. You can then distinguish between null caused by an uninitialized field (probably a programming error)|COMMA| vs null as a result of some action.
T123 0 u_Dilruk : CAUTION: Assertions can be disabled and are found to be disabled in production environments.
T121 0 u_Kemal_Erdogan : null object pattern is useful for only simple cases because of java's lack of multiple inheritance. Unfortunately|COMMA| null is the only value that can stand for an arbitrary object and that is why it is used so widely.
T121 0 u_Xunnamius : I find myself using the Null Object DP when having the API "always available" is relevant (such as with the Strategy pattern)|COMMA| but I typically find myself simply throwing verbose and meaningful exceptions. I can't remember the last time I explicitly checked for null in Java (or any real OO language); then again|COMMA| I don't code in Java all that often. I just want to say: this was an epic conversation and a very enlightening read. This is why I come to SO. Thank you all for participating in this.
TH 0 u_sprinter : There is a much better solution for this now in Java8: use an Optional as your return value to represent a nullable value. That way the caller knows that it is an optional value and can use all the methods that Optional provides for handling the value.
T119 0 u_John_Mercier : I like the idea of a DO_NOTHING action but nobody seems to mention throwing an IllegalArgumentException. If the argument is invalid this seems like a good response. The method will need to have proper documentation either way. Also @sprinter returning a DO_NOTHING action is very similar to Optional. Both have the goal of not returning null. I'm not convinced that Optional is "a much better solution" though.
TH 0 u_Kevin_Krumwiede : By and large|COMMA| the problem is not that developers don't know or trust the contracts; the problem is that there are no contracts. In my experience with the Android SDKs published by several hardware vendors|COMMA| there is either no documentation or no useful documentation. The code mills in Hong Kong and Bangalore have never even heard of Javadoc.
TH 0 u_Josh : As an electronic eng. turned into a programmer|COMMA| this topics spin my head as I try to learn more XD
TH 0 u_Demonblack : throwing an Error just because someone passed a null file path to your file opener thingy is extremely overkill. Imagine if someone used that inside an application server.
TH 0 u_Mike : The real question is WHEN null is valid response and when is not. And what would be that very contract for software to be least cluttered with boilerplate code.
TH 0 u_Pascal_Schneider : Since Java 8|COMMA| I always use Optional for cases like this. From the point of readybility it's not a big difference IMO|COMMA| but it looks a bit more aesthetic. So instead of if (obj != null) I write if (objOpt.isPresent())
T121 0 u_ : @MetroidFan2002 Added to your statement - Criticism of NullObjectPattern
TH 0 u_Osmar : I've seen too many dumb NullPointer exceptions in Production as to think that defensively checking for nulls is a "Junior to Intermediate developers problem" In my opinion|COMMA| always|COMMA| always do Null checking
T119 0 u_Singed : @MetroidFan2002 "If the find action method cannot find an action|COMMA| then returning null is the right thing to do" This is totally up to the designer of the program to decide whether an action that doesn't do anything fits his use case. it is totally valid to return an action that doesn't do anything if it fits your design. You imply that real/fake action differentiation is important to the caller|COMMA| but both approaches are valid according to your use case. The case where not found action is important to the caller is also legit|COMMA| but can be communicated through other means than returning null
TH 0 u_JFreeman : As a person new to java i find it interesting that people would find it useful to do this. Why would a programmer not always instead write a try/catch statement and use that to avoid and resolve errors?
TH 0 u_Rasmus_Kaj : The second half of this example basically says do not use Java. While that might be a good idea|COMMA| sometimes you don't have a choise. And in java|COMMA| null is a valid value.
TH 0 u_bltxd : A find method opens up the possibility that it didn't find what we were looking for. A habit that works well for me is to use 2 distinct verbs for functions which can obviously fail: findXXX may fail and as such may return null or better an option|COMMA| getXXX may only fail by throwing an exception. I've also seen variants such as find vs find_exn or find vs find_opt. One way or the other|COMMA| as long as the usage is regular this is fine.
T121 0 u_Demonblack : The NOP approach is almost never a good one|COMMA| in my opinion. Like others have said|COMMA| it may hide deeper flaws in your program so that they only get found in production after weeks of troubleshooting. That's not always the case|COMMA| obviously|COMMA| but I would be extremely wary of using it. The rigorous and arguably correct answer to "find me X" when you don't find it is to return null if you expect it to possibly not be found|COMMA| or throw an exception if it's not an expected outcome. (e.g. I would expect a findByName method to be able to return null|COMMA| but a getById never should.)
TH 0 u_ch271828n : How about using the Optional<T>?
TH 0 u_Joffrey : How about using Kotlin?
T125 0 u_Rok_StrniÅ¡a : If you want to make a HashMap thread-safe|COMMA| use Collections.synchronizedMap().
T124 0 u_erickson : I would also comment that the naive approach to thread-safety in Hashtable ("synchronizing every method should take care of any concurrency problems!") makes it very much worse for threaded applications. You're better off externally synchronizing a HashMap (and thinking about the consequences)|COMMA| or using a ConcurrentMap implementation (and exploiting its extended API for concurrency). Bottom line: the only reason to use Hashtable is when a legacy API (from ca. 1996) requires it.
T126 0 u_Gaurava_Agarwal : HashMap gives flexibility to programmer to write threadSafe code when they actually use it. It happened rarely that I needed a thread safe collection like ConcurrentHashMap or HashTable. What I needed is certain set of functions or certain statements in a synchronized block to be threadsafe.
T127 0 u_Maneesh_Kumar : Hashtable is obsolete and we are using HashMap for non thread safe environment. If you need thread safety then you can use Collections.synchronizedMap() or use ConcurrentHashMap which is more efficient that hashtable.
T127 0 u_Jilles_van_Gurp : It's obsolete but not deprecated and I'm wondering why this is. I'm guessing removing this class (and Vector for the same reasons) would break too much existing code and annotating with @Deprecated would imply an intention to remove the code|COMMA| which apparently is not there.
T128 0 u_rashid : You can also use ConcurrentSkipListMap (docs.oracle.com/javase/10/docs/api/java/util/concurrent/â€¦). It is thread-safe collection similar to ConcurrentHashMap and this map is sorted according to the natural ordering of its keys|COMMA| or by a Comparator provided at map creation time.
T130 0 u_tedders : Theory: Goats are found in all kinds of precarious places|COMMA| like sheer cliffs|COMMA| possibly bucking location trends they get from regular non-goat users. Might explain "teleportations"|COMMA| which could be goats appearing to wildly relocate as the software tries to determine their location with algos designed for non-goats.
T132 0 u_LarsH : How does this answer add anything to the info that the question already showed?
T132 0 u_djechlin : @LarsH - the source for one.
T131 0 u_casperOne : This is a history lesson|COMMA| not an answer. Even if it is an Easter egg|COMMA| is there a valid use case for it? Being an Easter egg doesn't preclude it from being useful|COMMA| and you've not shown whether it is or is not useful.
T132 0 u_LarsH : @djechlin|COMMA| one aspect of the source is informative|COMMA| and now that the answer has been edited|COMMA| it's far more obvious: (this implementation of) this method always returns false.
TJ 0 u_Thorbj&#248;rn_Ravn_Andersen : The method could be overridden in a test scenario.
T130 0 u_ : It's also a reference to en.wikipedia.org/wiki/The_Men_Who_Stare_at_Goats |COMMA| about a U.S. military project involving goats.
TJ 0 u_logain : The monkey function is to detect the MonkeyRunner debug tool as specified in another answer.
T133 0 u_ : They need to add canPigsFly(). while (!canPigsFly()) { /* code */ }
T130 0 u_ : That's a real app.
T129 0 u_Martin_Konecny : I feel bad for anyone who cheekily used this function|COMMA| expecting it to return false forever.
T131 0 u_Ced : @casperOne given the content of the method I think the use case is pretty self explanatory.
T130 0 u_ : What's funny is there's an app with that ID: play.google.com/store/apps/â€¦. And it's not free|COMMA| nor made by Google!
T130 0 u_user253751 : @raulk Yes|COMMA| they used the ID of that app|COMMA| they didn't pick a random app ID and then happen to have someone create an app with that ID...
T130 0 u_ : App is available for free through Amazon app store amazon.com/Coffee-Stain-Studios-Goat-Simulator/dp/B013KNQ2MS
T135 0 u_djechlin : My bad - those are warnings|COMMA| however they often lead to actual compile errors if you are returning from a block that control flow is now forced down.
T137 0 u_Andy : Wouldn't compiler directive be a better use for conditions you want to compile out?
T135 0 u_josefx : @djechlin I do not know if this is android only|COMMA| in standard java ` if(false){...}` compiles just fine (open jdk javac 1.6 and 1.7)
T135 0 u_djechlin : @josefx - compiler warnings and can lead to errors if the branch the code is forced down has a return statement as this produces unreachable code. This is a useful compiler error; e.g. if you forget break; statements in a switch and your default case throws an exception|COMMA| you will get this error.
T135 0 u_josefx : @djechlin sorry|COMMA| I somehow failed to read your first sentence after seeing your (1==2) example - that if(false) is handled by the compiler is a downside in this case (and I should get some sleep to avoid more of these mistakes :-)).
T136 0 u_djechlin : @PeterOlson - if you are specifically trying to test a code branch where an if goes false or true|COMMA| this is the most precise and obvious way to simulate that - commenting out the block could be less accurate if you don't match to the proper end of the block (perhaps you didn't notice a discreet if/else block immediately following)|COMMA| it will lead to a compile error if you're forcing to the following else block|COMMA| etc.
TK 0 u_ : For "if (false)"|COMMA| check end of doc docs.oracle.com/javase/specs/jls/se7/html/jls-14.html#jls-14.21
TK 0 u_Mike : It is legal because a sub-class could override isUserAGoat() and return a different value.
T137 0 u_djechlin : @Vadzim nope|COMMA| compiler will detect that always evaluates to true.
TK 0 u_njzk2 : possibly because isUserAGoat is not final.
T134 0 u_Mark_Whitaker : provided the implementation doesn't change - and there's the problem. This is a disastrous way to implement a warning-free "if (false)" because the implementation can and does change. See my answer to this question: as of API21 isUserAGoat() returns true if a user has a specific app installed. Good luck diagnosing that when your code suddenly starts behaving oddly on "random" devices!
T134 0 u_thedayturns : @MarkWhitaker Or if goats start using devices.
T134 0 u_Szymon_Drosdzol : @thedayturns If goats start using Android devices this will be the least of our problems.
T138 0 u_user253751 : @djechlin No it isn't|COMMA| did you actually try it?
T138 0 u_djechlin : @immibis what's that referring to?
T138 0 u_ : @djechlin if(false) {/* stuff */} not compiling.
T138 0 u_djechlin : @immibis guess you're right. Certainly gives this answer a long run of misinformation (and I had at least one chance to read a JLS citation and realize this). It's maybe material enough to keep around if the "Eclipse warning/error" happens but I will have trouble checking given my lack of Eclipse environment. At the least|COMMA| I brought it up to being technically factual.
TK 0 u_ : @djechlin could you please remove the aforementioned misleading comment (stackoverflow.com/questions/13375357/â€¦) - a lot of people his this answer|COMMA| and|COMMA| since newbies usually believe highly-upvoted things|COMMA| we're actually educating newcomers that if(false){} is a compiler error in Java...
TK 0 u_BlueWizard : have you tried using /* and */ for commenting out code?
TK 0 u_djechlin : @JonasDralle this is obviously a ridiculous answer|COMMA| but that won't work for code that already has /* */ inside of it. It's also easy to mess up blocks that way if if ends in } } } } } } } }.
T139 0 u_bad_keypoints : So i+=j compiles as I checked myself|COMMA| but it would result in loss of precision right? If that's the case|COMMA| why doesn't it allow it to happen in i=i+j also? Why bug us there?
T139 0 u_Lukas_Eder : @ronnieaka: I'm guessing that the language designers felt that in one case (i += j)|COMMA| it is safer to assume that the loss of precision is desired as opposed to the other case (i = i + j)
T139 0 u_bad_keypoints : No|COMMA| its right there|COMMA| infront of me! Sorry i didn't notice it earlier. As in your answer|COMMA| E1 op= E2 is equivalent to E1 = (T)((E1) op (E2))|COMMA| so that's kind of like implicit down typecasting (down from long to int). Whereas in i = i+j|COMMA| we have to do it explicitly|COMMA| ie|COMMA| provide the (T) part in E1 = ((E1) op (E2)) Isn't it?
T142 0 u_nanofarad : I'd assume that this is used to avoid an explicit cast and/or f postfix in the situation of adding a double literal to a short?
TL 0 u_Hans : So is E1 op1 op2 op3 = E2 valid and equivalent to E1 = T(E1 op3 (E1 op2 (E1 op1 E2)))?
TL 0 u_Lukas_Eder : @Hans: You can't have several "ops" to the left of an assignment operator... I'm sure this is covered elsewhere in the JLS
T140 0 u_ThePyroEagle : A likely reason to why the Java compiler adds a typecast is because if you're trying to perform arithmetic on incompatible types|COMMA| there is no way of performing a typecast of the result using the contracted form. A typecast of the result is generally more accurate than a typecast of the problematic argument. No typecast would make the contraction useless when using incompatible types|COMMA| as it would always cause the compiler to throw an error out.
T141 0 u_pyb : Why is 3 + 4.6 rounded to 7|COMMA| not 8?
T141 0 u_Lukas_Eder : It's not rounded. It's cast (= truncated)
TL 0 u_Stefan_Neuhaus : The Puzzle 9 in the book "Java Puzzlers" (Joshua Bloch|COMMA| Neal Gafter) covers exactly this issue. In the solution the authors highlight 2 phrases: "Compound assignment expressions automatically cast the result of the computation they perform to the type of the variable on their left-hand side." --- "Do not use compound assignment operators on variables of type byte|COMMA| short|COMMA| or char."
T143 0 u_Nikos : Does this issue persist in Java today (Java 8|COMMA| or 9)?
T143 0 u_Lukas_Eder : @RestlessC0bra: I really really really hope that the JLS won't break incompatibly on that level :)|COMMA| so without trying (you could try this yourself)|COMMA| I'll say yes|COMMA| the "issue" persists
T144 0 u_Bill_the_Lizard : That will be backed by the original input array|COMMA| which is why you (probably) want to wrap it in a new ArrayList.
T144 0 u_Mikezx6r : Be careful with this solution. If you look|COMMA| Arrays ISN'T returning a true java.util.ArrayList. It's returning an inner class that implements the required methods|COMMA| but you cannot change the memebers in the list. It's merely a wrapper around an array.
T145 0 u_monksy : You can cast the List<Element> item to an ArrayList<Element>
T144 0 u_user85421 : @Mikezx6r: little correction: it's a fixed-size list. You can change the elements of the list (set method)|COMMA| you cannot change the size of the list (not add or remove elements)!
T146 0 u_PaulMurrayCbr : Yes|COMMA| with the caveat that it depends on what you want to do with the list. It's worth notng that if the OP simply wants to iterate through the elements|COMMA| the array doesn't have to be converted at all.
T145 0 u_glglgl : @monksy No|COMMA| you can't. As was said|COMMA| it is a different kind of ArrayList.
T147 0 u_Jingguo_Yao : This does not work if array element is of primitive type in Java 8. For details|COMMA| see stackoverflow.com/q/2607289/431698
T148 0 u_Daniel : For calls where max value is Integer.MAX_VALUE it is possible to overflow |COMMA|resulting into a java.lang.IllegalArgumentException. You can try with : randInt(0|COMMA| Integer.MAX_VALUE). Also|COMMA| if nextInt((max-min) + 1) returns the most high value (quite rare|COMMA| I assume) won't it overflow again( supposing min and max are high enough values)? How to deal with this kind of situations?
T151 0 u_Moishe_Lipsker : @momo the RANDOM class supports nextLong. You could use that instead of nextInt for longs.
T151 0 u_mmm : @MoisheLipsker It must be that nextLong doesn't take a bound as nextInteger
T151 0 u_b1nary.atr0phy : @momo Enlist help from the double. Just so: long val = ((long) (r.nextDouble() * (max - min))) + min
T151 0 u_mmm : Yes|COMMA| I already do that|COMMA| using the Math.random() which does that: public static long random(long min|COMMA| long max) { return min + Math.round( Math.random() * ( (max - min) ) ); }
T149 0 u_leventov : This snippet (that probably thousands of people copy) is BAD. It produce garbage. Just ThreadLocalRandom.current().nextInt(min|COMMA| max).
T149 0 u_Greg_Case : @leventov ThreadLocalRandom was added to Java 2 1/2 years after this question was first asked. I've always been of the firm opinion that management of the Random instance is outside the scope of the question.
T152 0 u_Greg_Case : @AbhishekSingh The comments try to address this|COMMA| but in more detail: nextInt(N) returns a number from 0 to N - 1|COMMA| i.e. it will never return N as a result. In this case we want to include N in our possible range of values|COMMA| so we add one: nextInt(N+1) => returns a number in the range 0 to N|COMMA| inclusive of both 0 and N
T150 0 u_Webserveis : In Android Random rand = new Random();
T150 0 u_Greg_Case : @Webserveis This is addressed in the comments in the example. Short version - you should not = new Random() for every call to the function|COMMA| or your results will not be sufficiently random for many cases.
T150 0 u_Chit_Khine : Shouldn't you initialize the rand = new Random()?
T150 0 u_Greg_Case : @ChitKhine Not on each call to the function. The RNG algorithm under the hood of Random works well (enough for non-cryptographic applications) when generating successive random numbers. However|COMMA| if the Random instance is re-created on each call|COMMA| that means that instead of a proper RNG you're going to get "random" numbers based on whatever seed is chosen each time - often this is based on the system clock. This can give decidedly non-random results. Instead|COMMA| you should consider instantiating your Random instance outside of method scope. The example code attempts to address this.
TM 0 u_ : Use ThreadLocalRandom.current().nextBytes(chunk); if you want to save yourself the new Random(). Thanks to a really popular question on generating random Integers in Java.
TM 0 u_Aman : and if you're using for android java ThreadLocalRandom.current().nextInt(1|COMMA| 100) it requires min API Level 21
T153 0 u_JustAnotherGuy : Do these methods return integers|COMMA| or real numbers. In other words|COMMA| what method should be called if my bounds were 1.33 < x < 4?
T153 0 u_Greg_Case : @JustAnotherGuy The examples in this answer strictly deal with integers. For the real numbers case|COMMA| a variant on the technique described in stackoverflow.com/a/363732/462 should work. Recommend not using Math.random() but instead an appropriate double-based method of ThreadLocalRandom or Random instead.
T154 0 u_ : Maybe these examples can help even more: apisonar.com/java-examples/â€¦
T156 0 u_Joachim_Sauer : I'd replace "completely useless" with "just a minor security improvement". For example you could get access to a memory dump if you happen to have read access to a tmp directory|COMMA| a badly configured machine and a crash in your application. In that case you wouldn't be able to install a keylogger|COMMA| but you could analyze the core dump.
T155 0 u_Dan_Is_Fiddling_By_Firelight : Wiping unencrypted data from memory as soon as you're done with it is considered a best practice not because it's foolproof (it's not); but because it reduces your threat exposure level. Real time attacks aren't prevented by doing this; but because it serves a a damage mitigation tool by significantly reduces the amount of data that is exposed in a retroactive attack on a memory snapshot (eg a copy of your apps memory that was written to a swap file|COMMA| or that was read out of memory yanked from a running server and moved to a different one before its state failed).
T158 0 u_kingdango : I tend to agree with the attitude of this response. I'd venture to propose most security breaches of consequence occur at a much higher level of abstraction than the bits in memory. Sure|COMMA| there are probably scenarios in hyper-secure defense systems where this may be of considerable concern but seriously thinking at this level is overkill for 99% of the applications where .NET or Java are being leveraged (as it related to garbage collection).
T159 0 u_Rolf_Rander : maybe localhost isn't what you want to protect. Maybe you have created a program running on an unsecure client and you need the password for accessing a database. If you don't trust the client and are trying to protect the database|COMMA| wiping passwords from memory is good advice.
T159 0 u_josefx : @RolfRander that is even worse|COMMA| you should not enter passwords on an untrusted client - use a one time key (not sure this is the right term|COMMA| a password that only works once and gets locked out after that use).
T159 0 u_Rolf_Rander : most websites use passwords for login. Your credit card number and security-digits is also a kind of password.
T159 0 u_josefx : @RolfRander there is nothing about websites that requires an untrusted client|COMMA| if the user chooses to use a compromised system then there is nothing that you can do to protect him from the consequences.
T159 0 u_Rolf_Rander : as I said|COMMA| the point might be protecting the server|COMMA| not the client. My point with the website-example is that there are lots of services using passwords (for different reasons|COMMA| although other mechanisms obviously would be more secure. Bottom line being that a scenario where you want to protect the server|COMMA| won't trust the client and are using passwords|COMMA| storing passwords in a char[] is a wise choice and this isn't really a far-fetched scenario.
T159 0 u_josefx : @RolfRander somehow I get the feeling that you use a single login for all your clients and don't have any security/validation serverside. Its your duty to make sure that a user can't compromise the database (access restrictions and validation serverside) and the users duty to make sure that his account can't be compromised (his password).
T159 0 u_Rolf_Rander : Absolutely. But for the user to make sure his password isn't compromised|COMMA| the software handling the password has to take care to reduce the chance that malware (on the client) can pick up passwords from the client application memory. To achieve that|COMMA| I believe storing the password in a char[] and overwriting this afterwards is good advice.
T161 0 u_Tinman : I'd say that of someone understands the thinking behind the char vs sting then they are more likely to be thinking of security when configuring the servers. Not thinking is what usually introduces security holes.
T157 0 u_Peter_vdL : After the Heartbleed penetration of server memory|COMMA| revealing passwords|COMMA| I would replace the string "just a minor security improvement" with "absolutely essential to not use String for passwords|COMMA| but use a char [] instead."
T157 0 u_josefx : @PetervdL heartbleed happened because someone got the great idea that reusing memory was cheaper than allocating new (cleared) memory|COMMA| you cannot reuse a String in Java|COMMA| just hope that nobody ever gets the idea to put your char[] into a reuse list for better performance.
T157 0 u_Peter_vdL : You're missing the point completely|COMMA| Josefx. The point is that heartbleed allowed remote reading of process memory|COMMA| which everyone had hitherto thought very unlikely. When combined with the use of Java strings|COMMA| passwords are easily revealed. Char [] allows the developer to blank out passwords|COMMA| String does not even give that opportunity. Char [] + heartbleed may be harmful if coder screws up. String + heartbleed == definitely always harmful.
T157 0 u_josefx : @PetervdL heartbleed only allowed reading of a specific reused collection of buffers (used for both security critical data and network I/O without clearing in between - for performance reasons)|COMMA| you cannot combine this with a Java String since they are by design not reuseable. Nor can you read into random memory using Java to get at the contents of a String. The language and design problems that lead to heartbleed are just not possible with Java Strings.
T157 0 u_josefx : @PetervdL then please do not refer the "heartbleed bug in combination with Java Strings" and I am sure most I mentioned in relation to heartbleed was correct|COMMA| the libreSSL developers got quite detailed on why OpenSSL was a security nightmare. There "may" be a way to use a bug in the JIT to bypass Javas build in range checks or the automatic zeroing of object memory and it "might" be possible for someone to trigger this from a remote location without crashing the JVM|COMMA| however that has nothing in common with heartbleed|COMMA| nor would any bug on the JVM be so simple or optimized for exploits.
T157 0 u_DavidS : @PetervdL It's not just not "specific" to the Heartbleed bug; it's totally inapplicable. I suggest you don't reference Heartbleed as justification for security measures until you have a better grasp of its nature. Thanks to josefx for shedding light on this often misunderstood issue.
TN 0 u_ACV : There is yet another case - when the JVM crashes and produces a memory dump.
TN 0 u_Dawesi : Why would you store the password in in memory? external system? web or api request submits a string (ironically)|COMMA| so it's in memory anyway at that point. I'd never store the login password in another variable (other than the readonly one it's sent to the server with) unencrypted for any reason? Should web requests convert letters to their char number equiv to submit so the request variable is a number? As there is no char datatype from the browser?
TN 0 u_Stefan_L : And for completeness let's not forget the more recent meltdown and spectre attacks: meltdownattack.com which could be exploited via a web browser or shared hosting environment.
T162 0 u_Benjamin_Wootton : Though old style|COMMA| this will help avoid ConcurrentModificationExceptions over the new foreach style in the answers below. You can for instance remove via the seperate iterator.
T160 0 u_ : @karim79 what do you think about the following way: Map<Integer|COMMA| Integer> map = new HashMap<Integer|COMMA| Integer>(); for (Map.Entry<Integer|COMMA| Integer> entry : map.entrySet()) { System.out.println("Key = " + entry.getKey() + "|COMMA| Value = " + entry.getValue()); }
T161 0 u_vim : by calling 'it.remove(); ' you are emptying the map making it not reusable if this map was a class variable. Do you have any solution to that?
T161 0 u_Danny : @vimukthi what do you mean a solution to that? Just remove the it.remove(); line.
T160 0 u_ : The for (Map.Entry<String|COMMA| Object> cursor : map.entrySet()) {...} syntax is much better.
T162 0 u_Whimusical : Is there any difference on chances of ConcurrentModificationExceptions between both syntaxs in terms of calling remove() or not? Some answers imply contradictory assertions (first vs fourth comments)
T164 0 u_etlds : Iterator interface is generic since 1.2. It need to be Iterator<E>
TO 0 u_Victor : I consider that the answer of arvnid|COMMA| despite is just a copy/paste or not. (I agree that is ethical to give the proper credits to the one who belongs)
T163 0 u_Puru-- : I landed up here accidentally|COMMA| why did we do Iterator.remove() here? OP just asked for a best way for iterating over a Map
TO 0 u_J_E_Carter_II : Note that it.remove will not work with unmodifiable Maps|COMMA| like System.getenv() return String Map.
TO 0 u_Moebius : The full type of iterator is : import java.util.Iterator;
TO 0 u_Hele : @harto's answer is a better one as it tells the reader how to actually use this in a variety of cases. Your solution's application range is tiny. Very tiny.
TO 0 u_ : Don't you jump over the first entry using the "linewhile (it.hasNext())"?
TO 0 u_Jwan622 : So the big picture steps seem to be 1. convert to a set using entrySet 2. turn it into an iterator and 3. call hasNext and turn each next Object into a Map.Entry Object?
T160 0 u_ashishduh : Everyone saying that for (Map.Entry<String|COMMA| Object> cursor : map.entrySet()) is better than this is ignoring the fact that you will still receive a ConcurrentModificationException using that method. The selected answer remains the best method to iterate through a Map.
TO 0 u_apraetor : @JÃ¼rgenK. No|COMMA| it.hasNext() returns a boolean based on whether the iterator has another element beyond the current one but does not advance the iterator's state. The iterator isn't advanced to the next element until it.next() is called.
TO 0 u_NimChimpsky : @Alex yeah me too
T160 0 u_nemetroid : @ashishduh The selected answer is only the best in the special case where you need to modify the map during iteration. For all other uses|COMMA| using an enhanced for loop is preferable.
TO 0 u_phil : This API is not intuitive|COMMA| so I google this answer repeatedly and was at least 20 times on this answer!!
T165 0 u_PaÅ­lo_Ebermann : @etlds Actually|COMMA| Java 1.2 introduced Iterator|COMMA| but didn't have generics back then. Generics were only added in 1.5.
TO 0 u_Impulse_The_Fox : Please do not use Iterator anymore.
TO 0 u_Androidcoder : i get unchecked cast and unchecked assignment warnings for '(Map.Entry)it.next()'. I did add a check to Map|COMMA|Entry: 'Map.Entry<Integer|COMMA|MyObject> entry' to avoid other issues.
TO 0 u_Rishabh_Agarwal : Since Map is not under Iterator class|COMMA| how can you use iterator with map ? Only List|COMMA| Queue and Set are iterable.
TO 0 u_Peter_Mortensen : Perhaps update this for Java 8? (E.g. providing two versions|COMMA| one for before Java 8 and one that only works on Java 8.)
TO 0 u_technazi : ConcurrentHashMap is an implementation of ConcurrentMap interface. ConcurrentMap Interface extends Map Interface. The confusion is because the question specifically asked for HashMap. HashMap is an implementation of Map interface. It is always better to declare a ConcurrentHashMap like: Map<String|COMMA|String> myMap = new ConcurrentHashMap<String|COMMA|String>(); instead of : ConcurrentHashMap<String|COMMA|String> myMap = new ConcurrentHashMap<String|COMMA|String>(); This first practice allows extensibility. That is the reason this is a mature answer.
TO 0 u_Mader_Levap : I consider it bad answer. OP was asking just for iterating over map|COMMA| not how to modify map during iteration.
T166 0 u_ : If you do that|COMMA| then it won't work as Entry is a nested Class in Map. java.sun.com/javase/6/docs/api/java/util/Map.html
T166 0 u_jjujuma : you can write the import as "import java.util.Map.Entry;" and it will work.
T167 0 u_assylias : @Pureferret The only reason you might want to use an iterator is if you need to call its remove method. If that is the case|COMMA| this other answer shows you how to do it. Otherwise|COMMA| the enhanced loop as shown in the answer above is the way to go.
T166 0 u_Josiah_Yoder : I believe the form Map.Entry is clearer than importing the inner class into the current namespace.
TP 0 u_Saras_Arya : where is map from map.entrySet() declared ?
TP 0 u_Fallenreaper : quick Question: do the Generic values <String|COMMA| String> need to match that of the Map? For Example|COMMA| mine is <String|COMMA| Foo>.
T170 0 u_intcreator : This is assuming your Map is named map of course. Beginners might not catch on.
T170 0 u_jpaugh : @brandaemon Agreed. Even for intermediates|COMMA| it's nice to see precisely which type implements the entrySet method.
T168 0 u_dguay : Note that you can use map.values() or map.keySet() if you want to loop through values or keys only.
T169 0 u_Marcus_MacWilliam : That is not efficient. The Map holds the data in an entry set. For speed always iterate over the entry set.
TP 0 u_Androidcoder : I get and incompatible types error for 'Map.Entry entry' and 'Map.Entry<Integer|COMMA|HashMap> entry: "required Object|COMMA| found Entry". I'm mapping integers to hashmaps. Having to use the keyset for loop because of this and pull the value through 'value = (HashMap) integertomap.get(key)'|COMMA| though less efficient then if I could use entrySet without iterater as per your example.
T169 0 u_JimmyB : @MarcusMacWilliam "The Map holds the data in an entry set" - This is not true for many Map implementations. See TreeMap implementation for example which traverses the tree for either keys|COMMA| values or entries.
T166 0 u_Marquis_of_Lorne : @ScArcher2 No it isn't. It is a nested interface|COMMA| and even if it was a nested c|COMMA|ass it would still work. This code works. Been using. It for 15 years. No import required.
T171 0 u_earcam : \+1 ClassLoader leaks are some of the most commonly painful memory leaks in the JEE world|COMMA| often caused by 3rd party libs that transform data (BeanUtils|COMMA| XML/JSON codecs). This can happen when the lib is loaded outside your application's root classloader but holds references to your classes (eg. by caching). When you undeploy/redeploy your app the JVM is unable to garbage collect the app's classloader (and therefore all classes loaded by it)|COMMA| so with repeat deploys the app server eventually borks. If lucky you get a clue with ClassCastException z.x.y.Abc cannot be cast to z.x.y.Abc
T172 0 u_bestsss : tomcat uses tricks and nils ALL static variables in ALL loaded classes|COMMA| tomcat has a lot of dataraces and bad coding though (need to get some time and submit fixes)|COMMA| plus the all mind-boggling ConcurrentLinkedQueue as cache for internal (small) objects|COMMA| so small that even the ConcurrentLinkedQueue.Node takes more memory.
T171 0 u_Adrian_M : \+1: Classloader leaks are a nightmare. I spent weeks trying to figure them out. The sad thing is|COMMA| as what @earcam has said|COMMA| they are mostly caused by 3rd party libs and also most profilers can't detect these leaks. There's a good and clear explanation on this blog about Classloader leaks. blogs.oracle.com/fkieviet/entry/â€¦
T174 0 u_Daniel_Pryden : @Nicolas: Are you sure? JRockit does GC Class objects by default|COMMA| and HotSpot doesn't|COMMA| but AFAIK JRockit still can't GC a Class or ClassLoader that is referenced by a ThreadLocal.
T172 0 u_Matthijs_Bierman : Tomcat will try to detect these leaks for you|COMMA| and warn about them: wiki.apache.org/tomcat/MemoryLeakProtection. The most recent version will sometimes even fix the leak for you.
TQ 0 u_ : For future references|COMMA| there is one more tool trying to solve classloader leaks: Plumbr
T174 0 u_DiveInto : @DanielPryden Does this gist(gist.github.com/4057644) shows what you described? but it won't go out of memory according to my test|COMMA|correct me if there is any misunderstanding|COMMA|thanks
T174 0 u_ : @DanielPryden I have update my gist|COMMA|please check: gist.github.com/4057644#gistcomment-595443
T175 0 u_Sid : Okay A little stupid question...Will it be termed as a memory leak|COMMA|if the GC(Garbage Collector) doesn't kicks in? I am not sure whether one can invoke GC explicitly.
T175 0 u_Daniel_Pryden : @Sid: the issue is not whether or not the GC actually runs (Raymond Chen argues that a no-op GC is a valid implementation|COMMA| see Everybody thinks about garbage collection the wrong way)|COMMA| it's whether|COMMA| even if the GC did run|COMMA| it would be unable to reclaim an object that is no longer visible to any running code. A ClassLoader leak is one way to end up with objects that cannot be found or used|COMMA| but that still occupy memory and are rooted for GC purposes|COMMA| so the GC cannot reclaim them.
TQ 0 u_Jack : It would be great if you could provide the code|COMMA| I could not get all the steps! How to create one with a non-static member ? thanks.
TQ 0 u_Daniel_Pryden : @JackMoore: I don't have "the code"|COMMA| this is just an example of a systemic problem. The issue is that a ThreadLocal creates a strong reference to an instance of a class|COMMA| and through that instance to the class itself (and to all data statically reachable from the class)|COMMA| including the ClassLoader that loaded the class. But you can clear all references to the ThreadLocal object instance and not clear the underlying GC reference as long as the referenced Thread is still running. Basically|COMMA| the Thread has an invisible|COMMA| uncollectable reference to the ThreadLocal storage|COMMA| which thus leaks.
TQ 0 u_Daniel_Pryden : @AfterWorkGuinness: See my response to Jack Moore. Does that make sense? The Thread itself can be a GC root even if|COMMA| for all other intents and purposes|COMMA| there are no more references to the given value reachable from Java code. If you have a thread pool and you load and unload classes using a ClassLoader|COMMA| it's entirely possible that any particular thread in the pool may outlive the classes|COMMA| and can this keep a large amount of memory (all classes in the ClassLoader|COMMA| and all data statically reachable from any of them) "reachable" for GC purposes although the values can't be reached from code.
TQ 0 u_AfterWorkGuinness : @DanielPryden could you post a code snipped for this ? I'm having trouble visualizing it.
TQ 0 u_Daniel_Pryden : @igaurav: Regarding your edit to this answer|COMMA| please see the discussion at meta.stackoverflow.com/questions/289814
T173 0 u_Tamas_Hegedus : I think this is not a "true" memory leak. One could still retrieve the loaded classes by investigating the Thread object's package visible threadLocals member field via reflection. So this isn't a more "true" leak than a simple unused private field.
T173 0 u_Daniel_Pryden : @TamasHegedus: It's true that you can find specific cases of this using reflection|COMMA| but that only works if the installed SecurityManager allows it|COMMA| and it also depends on you being able to programmatically identify a type as being no longer in use. In a constrained case this is certainly doable|COMMA| but I don't think it solves the general case.
T173 0 u_Tony : I am not sure whether I understand you right: The thread own the ThreadLocalMap which own threadLocal variable and class. But the content in ThreadLocalMap is weakly reachable|COMMA| shouldn't it be GCed when memory is not enough?
T173 0 u_Daniel_Pryden : @Tony: Each Thread holds strong references to every ThreadLocal. So the ThreadLocal values can't be GC'd as long as the thread keeps running. This kind of problem often surfaces in an application container that owns a thread or thread pool that runs as long as the JVM does|COMMA| which effectively keeps the garbage rooted forever. You're right though that if you ensure that all threads that could possibly be holding a ThreadLocal have been forcibly terminated|COMMA| you can fix the leak. But in a large application that can often be an intractable task.
T173 0 u_Tony : Sorry|COMMA| but I can't find any reference about 'Each Thread holds strong references to every ThreadLocal.'. From source|COMMA| the ThreadLocalMap's Entry is extended from WeakReference|COMMA| shouldn't it mean the entry may be GCed when no strong reference to the entry holds? Thank you.
T173 0 u_Daniel_Pryden : @Tony: the Javadoc on ThreadLocal says: "Each thread holds an implicit reference to its copy of a thread-local variable as long as the thread is alive and the ThreadLocal instance is accessible". Empirically this prevents a Class object for the type of value stored in a ThreadLocal from being GC'd while the thread is running: see the Gist I linked to in my answer for an example.
T173 0 u_Tony : Oh|COMMA| the class also have a strong reference to its static field(ThreadLocal in this case)|COMMA| so this make ThreadLocal stay in memory. Isn't it?
TQ 0 u_Brian_Bulkowski : When I ask a question in an interview|COMMA| especially like this|COMMA| the answer isn't "here's how you do it". I make a point of asking questions that don't have a look-it-up-on-stackoverflow answer. Instead|COMMA| I expect a discussion about what a memory leak is|COMMA| how java works|COMMA| the internal data structures. I am hoping for "If you mean having a process consume a ton of memory and halt|COMMA| there are a bunch of ways|COMMA| I can show you a handful. Is that what you want? It's not technically a leak though." ( Then code it in 2 lines ). Or tell a war story about tracking one down. That's the person I want to hire.
TQ 0 u_AMDG : Note that|COMMA| since Java 8|COMMA| there is no longer a permgen but the Metaspace. Memory leaking still persists|COMMA| but the main difference besides the name is that Metaspace size can be auto-incremented.
TQ 0 u_Philip_Rego : I'm getting a recourse leak. I'm calling Class.forName("com.informix.jdbc.IfxDriver"); in a scheduled thread. Would that cause a resource leak? @TamasHegedus
TQ 0 u_Tamas_Hegedus : @philiprego no|COMMA| that wouldn't as far as you load the same driver every time
TQ 0 u_Artanis_Zeratul : @community wiki|COMMA| so what if I can't get away with long running threads? like I need to fetch something perpetually from the DB or somewhere else?
TQ 0 u_Daniel_Pryden : @ArtanisZeratul: It sounds like you're trying to ask a new question. You can do that by clicking "Ask Question". And "community wiki" isn't a person|COMMA| it just means that all of the answers to this question are owned by the whole community rather than individuals.
T173 0 u_Malcolm : Why this elaborate scheme with the ClassLoader though? Why isn't it enough to create some objects and put them into ThreadLocal?
T173 0 u_Daniel_Pryden : @Malcom: The reason the ClassLoader makes a difference is because|COMMA| if you lose the reference to the Class that contained the reference to the ThreadLocal|COMMA| you no longer have any way to get a reference to the ThreadLocal object. So the memory is leaked because you can't write code that can remove|COMMA| or even retrieve|COMMA| the leaked object anymore.
T173 0 u_jcsahnwaldt_Reinstate_Monica : @DanielPryden: @Malcom is right. When the value of the ThreadLocal points back to the ThreadLocal object itself (maybe directly|COMMA| or through some intermediate references)|COMMA| there's a leak. It doesn't matter if the intermediate references are in a ClassLoader or not. Here's a small example that creates a memory leak simply by creating a ThreadLocal object that directly points back to itself: repl.it/@jcsahnwaldt/ThreadLocalLeakExample
T173 0 u_jcsahnwaldt_Reinstate_Monica : @Tony: "Oh|COMMA| the class also have a strong reference to its static field (ThreadLocal in this case)|COMMA| so this make ThreadLocal stay in memory. Isn't it?" - Well|COMMA| the main thing is that the value of the ThreadLocal is a (direct or indirect) reference to the ThreadLocal itself. Due to some details of the ThreadLocal implementation in Sun's/Oracle's JDK|COMMA| this creates a leak. The exact reference path to the ThreadLocal - whether directly|COMMA| through static fields|COMMA| or through instance fields - doesn't matter.
T173 0 u_jcsahnwaldt_Reinstate_Monica : By the way|COMMA| the original implementation of ThreadLocal in JDK 1.2 didn't have that problem. Give it a try: download github.com/fanhongtao/.../jdk_1.2.1/.../ThreadLocal.java|COMMA| remove the package declaration|COMMA| and compile and run it with @DanielPryden's sample code - no memory leak! (That implementation had other problems though. Josh Bloch mentions some of them here: cs.oswego.edu/pipermail/concurrency-interest/2007-October/â€¦ )
T173 0 u_jcsahnwaldt_Reinstate_Monica : @Jepessen: "I just don't understand why the thread must be long-running" - In Sun's/Oracle's implementation of ThreadLocal|COMMA| thread-local values are actually stored in a map that is attached to the thread. When the thread dies|COMMA| the garbage collector eventually clears this map|COMMA| which would also remove the memory leak in this example. github.com/openjdk/jdk/blob/master/src/java.base/share/classes/â€¦
T178 0 u_Kip : Wow! I'll try to convert this to Java and do a comparison|COMMA| as well as an accuracy check on the results. I'll let you know what I find.
T178 0 u_Kip : Testing on all values is impossible|COMMA| but a test on suspect values (+/- 1 from very large perfect squares) has proven to be accurate. On a run of the first billion integers|COMMA| this only took 34% of the time required by the original algorithm.
T178 0 u_A._Rex : Awesome! I'm glad it worked out for you. One thing that's different in C(++) and Java is that Java checks bounds on array lookups|COMMA| so I thought you might take a hit there.
T179 0 u_Dimitre_Novatchev : Seems that this only returns true/false|COMMA| but it will be difficult to return the square root itself?
T176 0 u_ShreevatsaR : Wow|COMMA| this is beautiful. I'd seen Hensel lifting before (computing roots of polynomials modulo a prime) but I hadn't even realised the lemma could be carefully lowered all the way for computing square roots of numbers; this is... uplifting :)
T179 0 u_A._Rex : @Dimitre Novatchev: No|COMMA| it would not be too difficult. If the number is a perfect square|COMMA| then its square root is r times some power of 2|COMMA| which can be determined when dividing out by powers of 4.
T179 0 u_ : @A. Rex: HotSpot is able to eliminate bounds checks in certain circumstances stackoverflow.com/questions/4469483/bounds-checking-in-java so the hit is probably being avoided.
T179 0 u_orlp : @A. Rex: I might be mistaken|COMMA| but isn't 9 a perfect square? And doesn't if( x < 0 || (x&2) || ((x & 7) == 5) || ((x & 11) == 8) ) return false; filter it out as not being one? And similar for all other uneven perfect squares?
T179 0 u_ : @nightcracker It doesn't. 9 < 0 => false|COMMA| 9&2 => 0|COMMA| 9&7 == 5 => false|COMMA| 9&11 == 8 => false.
T177 0 u_Jason_C : Maartinus posted a 2x faster solution (and much shorter) down below|COMMA| a bit later|COMMA| that doesn't seem to be getting much love.
T179 0 u_maaartinus : @A.Rex AFAIK|COMMA| the final test t <= (1LL << 33) is useless as you either get a square root or overshoot anyway. I dropped it and it works (but maybe there's a gotcha with numbers I haven't tried?).
T180 0 u_user1914292 : It seems like a lot of the speed advantage in the different solutions is gained by filtering out the obvious squares. Did anyone benchmark the situation of filtering out via Maartinus' solution and then just using the sqrt function as that's a built-in function?
TR 0 u_ : LL in y & 4294967295LL not needed.
TR 0 u_Ma&#235;lan : â€œNext|COMMA| check if it's a square modulo 255 = 3 * 5 * 17. Because that's a product of three distinct primes|COMMA| only about 1/8 of the residues mod 255 are squares.â€ Actually|COMMA| the proportion of squares modulo 255 is 54/255 â‰ƒ 0.212|COMMA| much more than 1/8 = 0.125 (because the proportion of squares modulo each of the prime factors are slightly more than 1/2). But note that you are not limited to primes. The proportion of squares modulo 256 is 44/256 â‰ƒ 0.172|COMMA| and computing modulo 256 is much more convenient.
TR 0 u_Ma&#235;lan : Thatâ€™s essentially one of the things maaartinusâ€™ answer does|COMMA| except that it uses 64 instead of 256 (which gives a more compact precomputed table with a better cache behavior|COMMA| while still being pretty efficient at filtering out non-squares|COMMA| as the proportion of squares modulo 64 is 12/64 â‰ƒ 0.188).
T181 0 u_Covar : Worth noting PrintWriter will truncate the filesize to zero if the file already exists
T181 0 u_leonbloy : PrintWriter can be (and often is) used|COMMA| but is not (conceptually) the right class for the job. From the docs: "PrintWriter prints formatted representations of objects to a text-output stream. " Bozho's answer is more correct|COMMA| though it looks cumbersome (you can always wrap it in some utility method).
T184 0 u_adesh_singh : will it print the html file as well?
T184 0 u_JBA : @adeshsingh no one ever tried out so faar|COMMA| be the first one!
T182 0 u_Marlon_Abeykoon : So where will the textfile will be created after the app is build and used in another PC since we have not given the path?
T182 0 u_Michael : @MarlonAbeykoon Good question. The answer is that it will create the text file in the working directory. The working directory is whatever directory you execute your program from. For example|COMMA| if you execute your program from the command line|COMMA| then the working directory will be whatever directory you are "in" at that moment (on Linux|COMMA| type "pwd" to see the current working directory). Or|COMMA| if I double-click a JAR file on my desktop to run it|COMMA| then the working directory will be the desktop.
T181 0 u_Rondo : If you want to append and not truncate u can replace PrintWriter with FileWriter: FileWriter(new File ("the-file-name.txt")|COMMA| true).. one trade-off is FileWriter assumes default character encoding and buffer sizes
T185 0 u_kamoroso94 : The syntax for declaring the byte array is incorrect. Should be byte[] data = ....
T183 0 u_Thierry : writer.close() should be in a finally block
T181 0 u_Apollys_supports_Monica : Why is it bad practice to use PrintWriter for this job? Does it perform more slowly?
T181 0 u_ : @Apollys PrintWriter swallows exceptions: stackoverflow.com/a/1747092/4678667
TS 0 u_lokesh : I would suggest to use File.createNewFile() method to create and verify file creation success. It returns a boolean value : true if the file is created successfully. I don't like waiting for exceptions to tell something has failed. Only after file has been created and you have verified it|COMMA| start writing data into it. It can save many bytes. Ref
T186 0 u_Bathsheba : In short then|COMMA| Java intentionally allows it: the "bug" is in the OP's IDE?
T186 0 u_Aaron_Digulla : @Bathsheba: It's more in the heads of people. People don't try to understand how Java parsing works|COMMA| so IDEs sometimes display the code in a wrong way. In the example above|COMMA| the comment should end with \u000d and the part after it should have code highlights.
T187 0 u_Aaron_Digulla : Another common mistake is to paste Windows paths in the code like // C:\user\... which leads to a compile error since \user isn't a valid Unicode escape sequence.
TT 0 u_Reg : I understand introduction of unicode characters|COMMA| but not so much why it is allowed in comments?
T188 0 u_bluelDe : In eclipse the Code after \u000d is highlighted partially. After pressing Ctrl+Shift+F the character is replaced with new line and rest of line is wrapped
T189 0 u_TheLostMind : So.. this is related to how the compiler parses the source-code file?. This problem can't be reproduced when we use block comments instead of single line comments
TT 0 u_aioobe : @Reg|COMMA| there are many features of the language that doesn't make sense in conjunction with other features of the language. In this case|COMMA| the language designers put the unicode escape handling before the parser|COMMA| and being able to use unicode escapes in commens was simply a (possibly unfortunate) side effect.
TT 0 u_Gregor_Ra&#253;man : While I agree with the answer from @aioobe that the source code is valid and the problem is rather in the IDE (and the source code highlighter on StackOverflow)|COMMA| please note that there is another "problem" with the code. The CR character entered as unicode escape sequence is interpreted as a correct start of a new line|COMMA| but the line number is not incremented.
T188 0 u_aioobe : @UmaKanth|COMMA| // comments are skipped all the way to the next new-line character. \u000d is interpreted as a new-line character.
T189 0 u_Taemyr : @TheLostMind If I understand the answer correctly you should be able to reproduce this with block comments as well. \u002A/ should end the comment.
T189 0 u_ : @Taemyr wow|COMMA| \u002A/ is really evil|COMMA| eclipse utterly fails to parse it. Put code between /*\u002A/ and /\u002a*/ and it's completely hidden as comment. Found this as bug 3533
T190 0 u_R.._GitHub_STOP_HELPING_ICE : Note that this could have been avoided completely if the language specification had forbidden using \u notation to represent anything representable in ASCII.
T190 0 u_Ben : @r good point|COMMA| well made. At the very least this should be a Level 1 Compiler Warning.
T190 0 u_Mooing_Duck : @R..: That would make it so that if you're developing on a computer that doesn't use ASCII|COMMA| then there are many characters you can't type in|COMMA| such as IBM Mainframes that use EBCDIC|COMMA| which doesn't have curly braces.
T190 0 u_R.._GitHub_STOP_HELPING_ICE : @TBohne: Do you actually have in mind such a character?
T190 0 u_Mooing_Duck : @R..: Yes|COMMA| curly braces. {}
T190 0 u_R.._GitHub_STOP_HELPING_ICE : @TBohne: Wikipedia claims they're at positions C0 and D0 in EBCDIC. It seems pretty ridiculous to expect programmers to use \u escapes for something as ubiquitous as braces...
T190 0 u_Mooing_Duck : @R.: A quick glance shows you're right. But it also contains "Portability is hindered by a lack of many symbols commonly used in programming and in network communications|COMMA| such as the curly braces." and "It exists in at least six mutually incompatible versions". I assume it must be a different version.
T190 0 u_supercat : @R..: One wouldn't have to forbid everything in ASCII if one were to specify that the first pass of compilation is subdivision into lines|COMMA| and any new-line characters that get introduced after that will be processed as-is|COMMA| such that string st="Hello\u000D\u000Athere" would generate a twelve-character string containing a carriage return and a new-line.
TT 0 u_Jean-Fran&#231;ois_Savard : If ever anyone is skeptic and want to test the hello world program|COMMA| the class should be named "Ugly.java". There is other funny thing that may be caused by this... For example|COMMA| insert LRM character will allow you to compile code such as for (char câ€® = 1; câ€® > 0; câ€®++)
TT 0 u_Jean-Fran&#231;ois_Savard : @biziclop Can we call it comment of the day even if it was posted 8 days ago ? :/
T191 0 u_Supuhstar : How efficient is this?
T191 0 u_Trevor_Brown : Worth a read: jaxenter.com/â€¦ tl;dr - streams could be performant or not|COMMA| it depends on what you're doing with them and the constraints of the problem (isn't this always the answer? lol)
T191 0 u_Marcin_Zukowski : Yeah|COMMA| it's a risky solution from the performance point of view. It might be fast|COMMA| but I wouldn't bet my application's performance on it ;)
T192 0 u_Will_Hardwick-Smith : Additionally|COMMA| if a or b are arrays of primitive types|COMMA| their streams will need to be .boxed() so they are of type Stream rather than e.g. IntStream which cannot be passed as a parameter to Stream.concat.
T192 0 u_Holger : @Will Hardwick-Smith: no|COMMA| you only have to pick the right stream class|COMMA| e.g. if a and b are int[]|COMMA| use int[] both = IntStream.concat(Arrays.stream(a)|COMMA| Arrays.stream(b)).toArray();
T191 0 u_Lii : @Supuhstar: It is probably not as fast as System.arrayCopy. But not particularly slow either. You probably have to do this a very many times with huge arrays in really performance sensitive contexts for the execution time difference to matter.
T191 0 u_Sina_Madani : I wonder which is faster and more memory efficient: the concat method or flatMap? Or are they the same under the hood?
T195 0 u_Dave_L. : The latter solution is nice because it can be used for more than 2 arrays unlike most (if not all) the other answers.
T191 0 u_Holger : @SinaMadani with all known implementations|COMMA| the variant using concat will be faster and need less memory|COMMA| because it can predict the resulting array size beforehand and will create and fill only one array. In contrast|COMMA| the flatMap based solution will have to use a resizable buffer internally|COMMA| with at least one final copying step.
T194 0 u_Artsiom_Chapialiou : Is it possible to make it works for generic type (like in the answer above)? Something like T[] both = Stream.of(a|COMMA| b).flatMap(Stream::of).toArray(T[]::new); Looks like T[]::new isn't allowed cause of type erasure...
T194 0 u_Lii : @ArtsiomChapialiou: You can|COMMA| but it's not so pretty. You have to use reflection to create the array|COMMA| and thus get an unchecked cast. I added that to the solution text.
T196 0 u_ : This answer is more correct than try it because current behavior is not the same as guaranteed behavior.
T197 0 u_ : This question comes into play during Joshua Bloch's chapter on object equality in Effective Java - amazon.com/Effective-Java-Edition-Joshua-Bloch/dp/0321356683
T197 0 u_Andy_Thomas : Specifically|COMMA| in Item 8|COMMA| he notes that in equals() methods|COMMA| one instanceof operator serves two purposes - it verifies that the argument is both non-null and of the correct type. "...[S]o you don't need a separate null check."
T198 0 u_Ben_Thurley : I don't see them ever changing this. It can only return true or false so how can can it ever be true for a null reference to be an instanceof anything?
T198 0 u_Andy_Thomas : @BenThurley - Java's instanceof operator was part of Java 1.0|COMMA| released almost 20 years ago. Changing the behavior now in a way that would break existing code is unlikely|COMMA| absent some benefit that outweighs that huge cost. Twenty years ago|COMMA| maybe there could have been arguments for returning true iff the argument could be cast|COMMA| or throwing an exception for a null argument. But those definitions would have required separate null checks.
T198 0 u_Ben_Thurley : Exactly my point. It's true that current behaviour is not the same as guaranteed behaviour but in this case I think it's pretty well guaranteed.
T198 0 u_Andy_Thomas : @BenThurley - The behavior is guaranteed by Java specifications past and present. I think Luke's point addresses the limitations of experimentation in determining the guaranteed behavior of the present.
T199 0 u_GabrielBB : Why the compiler let you do this: "null instance of Class" lol. I mean|COMMA| if it is a hardcoded null|COMMA| it doesn't make sense to even ask it
T199 0 u_Holger : @GabrielBB thatâ€™s like writing with a red pen on a red paper. Even if it makes no sense|COMMA| itâ€™s possible due to the general possibility to combine an arbitrary pen with an arbitrary paper. And implementing a â€œwriting on the same colorâ€ check into a pen would complicate the technology for little to no benefit.
T200 0 u_Stephen_C : See "Additional Notes #1" of my Answer. For a better explanation of this problem.
T200 0 u_kmort : @StephenC Yes|COMMA| your answer is more complete (and of course|COMMA| +1)|COMMA| but this particular answer had the word "package" in it|COMMA| which allowed me to find what I needed fast. And it worked. So +1 Razavi. StephenC|COMMA| yours lacks the simple package example I needed as I am new to Java.
T201 0 u_John : This was exactly my problem. I have been wading through tons of Java doc and this concrete example is what I needed
T202 0 u_M-Razavi : Its better to make 'Runnable JAR File' to execute class file.
T201 0 u_Pixel : Yes|COMMA| concrete example is nice|COMMA| this worked perfectly. I'm sure the main answer is very thorough|COMMA| but it was difficult to see the tree for the forest. Nice one @Razavi
T201 0 u_Spara : I like this shorter and useful answer instead of accepted one!
T203 0 u_Alex_Spurling : This is probably the best solution presented so far. The reason I didn't spot this facility when I first looked at the DecimalFormat class is that it was only introduced in Java 1.6. Unfortunately I'm restricted to using 1.5 but it will be useful to know for the future.
TU 0 u_Martin_Clemens_Bloch : Doesn't work with exponent decimalformats|COMMA| say format("0.0E00"). It will in this example round 0.0155 to 0.0E00 instead of 1.6E-02.
T206 0 u_ : I tried this with: "#.##"|COMMA| rounding HALF_UP. 256.335f -> "256.33" ...(example comes from comments to @asterite's answer).
T204 0 u_Gomino : Please be carefull as DecimalFormat depend on your current Local configuration|COMMA| you may not get a dot as a separator. I personnally prefer Asterite's answer below
T207 0 u_CGK : Also be aware that you should not expect DecimalFormat to be thread-safe. As per Java docs: Decimal formats are generally not synchronized. It is recommended to create separate format instances for each thread. If multiple threads access a format concurrently|COMMA| it must be synchronized externally.
TU 0 u_user4919188 : how do i make it so that it does a proper rounding so it will not round 0.0004 to 0.001
T206 0 u_Thorsten_Niehues : Cannot get this working with HALF_UP: Example DecimalFormat df = new DecimalFormat("0.00"); df.setMaximumFractionDigits(2); df.setRoundingMode(RoundingMode.HALF_UP); df.format(3.775) returns 3.77
T205 0 u_Dawood_ibn_Kareem : It's not too difficult to create cases where this simply doesn't work. I wouldn't use this method if it's important to get the correct result.
T206 0 u_fishinear : @ThorstenNiehues Just because you specify it as 3.775|COMMA| does not mean it has that value internally. Internally it has a binary value|COMMA| and 3.775 cannot be represented exactly as a binary value. So it might have a value corresponding to 3.77499999999 internally. When rounding|COMMA| always add the expected accuracy of the value.
T206 0 u_Thorsten_Niehues : @fishinear THX :)
T210 0 u_digiarnie : Prior to me putting the high number for the threshold|COMMA| I had the settings set up like you said already but it still put in the wild card imports (i.e. I had "use single class import" checked and removed all packages in the "packages to use import with *"...
T210 0 u_duffymo : Working for me. Let me see what else I might have set. Version 9.0.3 for me.
T210 0 u_digiarnie : So if you do 11 imports of classes from the same package the wild card import doesn't kick in? As a test|COMMA| I have my threshold set to 2. If I import something from org.hibernate let's say|COMMA| it will put the import correctly (fully qualified). As soon as I import something else from org.hibernate it will stick in the wild card import|COMMA| which kind of tells me either my version of intellij doesn't behave like yours or the only solution is to put a high threshold so I never run into this issue
T211 0 u_ : If you're using IntelliJ 12 or later then this can be configured under "Code Style" -> "Java" -> "Imports"
T211 0 u_duffymo : Read my answer - see the "Click on the Settings" bit? It's been true since IntelliJ 7. Already been answered for more than three years.
T208 0 u_PotataChipz : In case it saves someone else the confusion: In my enthusiasm for never collapsing imports|COMMA| I put an unreasonably long string of 9's in the 'class count to use...' field|COMMA| and this caused IntelliJ 12 to silently ignore the value. '9999' works fine.
T208 0 u_Stephen_Hartley : Is there really no way to tell Intellij 15 never to use wildcard imports? I mean without specifying a class count??!
T208 0 u_duffymo : Why is adding a class count so oppressive? Why not ask JetBrains for an enhancement if this is so odious?
T208 0 u_MCory : For the record (at least in IntelliJ Ultimate 2016)|COMMA| trying to set the value to an extremely large number of 9's won't work. If you add more than 5 9's|COMMA| the "Apply" button grays itself out and the setting won't take - instead of just not allowing you to only enter 5 9's. I found this out because I was lazy and just wanted to add a bunch of 9's to make sure it would never be close to an issue at all :)
T208 0 u_duffymo : Looks like three nines should be enough. If you need more than a thousand imports I'd say your class should be refactored.
T209 0 u_Glenn_Bech : Can't believe programmes programmed a program for programmers the way this is programmed. This confusing dialog is still not fixed in 2016.3|COMMA| is there a bug for it|COMMA| or somewhere we can vote?
T212 0 u_Paulo_Merson : Interesting enough|COMMA| for Kotlin the option is less confusing: "Use import with '*' when at least [99] names used."
T209 0 u_Thorbj&#248;rn_Ravn_Andersen : @GlennBech Just contact them on the "Submit feedback" entry in the Help menu.
T213 0 u_StealthVice7 : Why is the nio package better? Does it work in the same way? What even is nio?
T213 0 u_Benoit_Vanalderweireldt : It's not fundamentally better and using the standard io package is fine|COMMA| I'm not sure where is your error coming from but having a clean example of file deletion (starting with a .) might be a good starting point.
T214 0 u_StealthVice7 : My program works perfectly fine with all other test files I made|COMMA| but not the .minecraft file.
T215 0 u_ : System.getProperty("user.home") returns the user's desktop on windows. Use System.getProperty("user.home") + "/.." or similar instead.
T215 0 u_StealthVice7 : What does /.. do? And my program was working fine with all other files with the way I had it.
T215 0 u_Benoit_Vanalderweireldt : / is the root path .. means the parent folder so /.. means the parent folder of root which is incorrect
T215 0 u_Majora320 : @BenoitVanalderweireldt Wrong|COMMA| with <somepath> + "/.." it means the parent folder of <somepath>|COMMA| so in this case it would return the parent folder of the desktop.
T215 0 u_ : /.. != '"<somepath>" + "/.."'
T215 0 u_StealthVice7 : Guys I figured out my mistake|COMMA| the folder had other files inside of it|COMMA| so I had to delete the insides before I could delete the folder.
T216 0 u_StealthVice7 : Hey can you guys undownvote my question? I can't post any more.
T217 0 u_Alderath : \+1. Imo|COMMA| this is more constructive than the top voted answer. It comes with two minor downsides though. The PriorityQueue does not support random access. You cannot do peek(elementIndex). So you cannot do e.g. Integer maxVal = prioQueue.peek(prioQueue.size() - 1);. Secondly if you're intending to use the PriorityQueue simply as a sorted list|COMMA| it will sound less intuitive to see PriorityQueue in the code than it would have been to see SortedList|COMMA| if such a data structure existed.
T218 0 u_Alderath : And|COMMA| after looking at the other question which someone linked in the comments|COMMA| another big disadvantage is that the iterator of PriorityQueue is not guaranteed to return elements in any specific order. So|COMMA| unless I am overlooking something|COMMA| the only way to e.g. print all objects in the PriorityQueue in order is to repeatedly poll() the queue until it is empty. To me|COMMA| this feels borderline retarted. To print the objects in a PriorityQueue twice|COMMA| you'd first have to copy the PriorityQueue and then poll() all objects from the original PriorityQueue and then pol()l all objects from the copy.
T218 0 u_Spoike : Hmm... looks like you're right Alderath. You can't use the iterator of PriorityQueue to get the elements in expected order. Looks like I have to edit my answer.
TV 0 u_bestsss : Sorted list is implemented via tree|COMMA| otherwise it's just way too costy
T219 0 u_bestsss : Priority queue is just a heap|COMMA| you can access only the top|COMMA| imo it does not belong to the answer of the question.
T220 0 u_Mike_&#39;Pomax&#39;_Kamermans : Also worth noting is that Collections.sort() even lets you define the compare function that is used to sort|COMMA| by using a Comparator object.
T221 0 u_user2223059 : I would argue that there is a need for some kind of sorted|COMMA| indexed collection. I'm working on an application|COMMA| and I need a data collection that is accessible via an index number|COMMA| but maintains a very specific order. I don't want to have to use sort() or comparators all the time. So yeah|COMMA| I'm probably going to create a custom collection that just inherits from Collection|COMMA| rather than list|COMMA| that fulfills this function.
TV 0 u_Caitlin : The TreeMultiset allows for multiples in a really weird way. If you have two objects that have the same key|COMMA| instead of actually inserting all of the objects into the Multiset|COMMA| it just keeps track of the count that match that key. This is fine if you are using primitives. But if you are using objects|COMMA| and plan on using other pieces of the object|COMMA| it won't return the objects expected.
TV 0 u_juanmf : @Spoike ` because the add methods should ensure that the element will reside in the index that the user specifies` actually|COMMA|it adds at the end|COMMA| you can specify index in a Map|COMMA| with put(). Am I confused?
TV 0 u_Spoike : @juanmf The key (or index) for a Map is not the same thing as the index for a List. Using put() there is no way for sure that putting something in a lower number and something in a higher number will come in the order you want when you iterate on the entrySet of the map (i.e. unless you sort the entrySet by the key).
TV 0 u_Torque : A huge downside to all of these suggestions is the missing .sub*-function that SourtedMap and SortedSet provide|COMMA| and that at least in my experience is the most needed feature.
TV 0 u_Marcono1234 : @Spoike|COMMA| the own implementation of a SortedList can be written more efficiently. Since a random access list is used (ArrayList) and you know that it is already sorted before adding a new item|COMMA| you can use Collections.binarySearch to get the index where the new item should be inserted.
T225 0 u_rmeador : You don't need to create a class to pass by reference in java (though that would certainly work). You can use the Integer class|COMMA| which is part of the standard library|COMMA| and it even has the benefit of being auto-boxed to and from int almost transparently.
T225 0 u_ILMTitan : @rmeador Integer is immutable|COMMA| so you still couldn't change its value. AtomicInteger|COMMA| however|COMMA| is mutable.
T225 0 u_Dan_Tao : @rmeador: I'm asking because I honestly don't know|COMMA| not to challenge you: how would this work|COMMA| what you're suggesting? What I mean is|COMMA| how can you assign a new value to x from within a method|COMMA| even if it is boxed as an Integer? (Is the Integer type not immutable?) I know that in .NET|COMMA| using C# for example|COMMA| you could box an int as object but you still wouldn't be able to assign a new value to the variable holding that int from within a method|COMMA| unless it were passed as a ref parameter.
T225 0 u_rmeador : @Dan Tao: yeah|COMMA| as @ILMTitan points out|COMMA| it's immutable... I forgot that little detail. The suggestion of AtomicInteger seems reasonable|COMMA| but I don't think you get autoboxing with that class.
T222 0 u_axtavt : @Dan: By the way|COMMA| x in your last example must be declared volatile|COMMA| otherwise it's an undefined behaviour and seeing 1s is implementation specific.
T222 0 u_Dan_Tao : @axtavt: Good point -- I actually discovered this myself after last updating my answer when I changed the code only slightly and saw different behavior (all 0s|COMMA| no 1s). I've updated the answer to include the volatile keyword so that the program's behavior is defined.
T224 0 u_ : simple answer: operator precedence of ++ before =. See cppreference.com/wiki/operator_precedence The "infinite loop" part of title is misleading.
T224 0 u_Dan_Tao : @burkestar: I don't think that link is quite appropriate in this case|COMMA| since it's a Java question and (unless I'm mistaken) the behavior is actually undefined in C++.
T223 0 u_Tom_Brito : Something to say about my last comment on the question?: It's very strange that in C language the behavior is different. Maybe in C it first read the value and then|COMMA| later|COMMA| it increments|COMMA| while in Java it increments then return the old value..
T223 0 u_detly : @Tom Brito - in C it's not defined... the ++ could be done before or after assignment. Practically speaking|COMMA| there might a compiler that does the same thing as Java|COMMA| but you wouldn't want to bet on it.
T226 0 u_Jason_C : This is a very verbose way of saying the right side of an assignment expression is evaluated first.
T224 0 u_ : @burkestar Operator precedence is irrelevant here because (x = x)++ isn't legal. And the "infinite loop" part of the title is a fact; it's not at all "misleading".
T227 0 u_jaxad0127 : Just to note|COMMA| main could be a keyword that is only usable as a name for a static method with an appropriate signature (or whatever). Note that super class calls use super in a way that makes it look like an identifier: super(foo); and super.foo|COMMA| but super IS a keyword (and before generics were added|COMMA| this was the only way to use it (that I can remember)).
T227 0 u_davidxxx : @jaxad0127 Interesting point but I don't agree completely. Actually it IS not and in the future it could probably not be for still compatibility reasons. If you defined main as a keyword in a new version of java|COMMA| it means that any code that uses main as method name (or any member names) will not compile any longer. The usage of super in generics doesn't have any side effect in existing code as generics didn't exist at this time.
T227 0 u_jaxad0127 : I just meant that it COULD have been done as a keyword. Just because it looks like an identifier|COMMA| doesn't mean it has to be.
T227 0 u_GeroldBroser_reinstates_Monica : @jaxad0127 Without going too deep into the JLS and for the two cases you mention I think it can be said that super is a special expression: It represents a reference to a Class object to be used with the object's constructor and its members.
T228 0 u_AJPerez : I would argue that main is still a better identifier than java1234. Using it for a "regular" method would be misleading|COMMA| but I'd have no problem naming a variable main|COMMA| if it's actually the main something in my method. java1234 is just awful|COMMA| names should be descriptive...
T229 0 u_jpmc26 : About the question|COMMA| is main a good identifier? It depends. I probably wouldn't bat an eye at a variable named main if the function I was looking at did something with water main data. I'd throw up if I ever saw java1234 in production code (and pray there were not 1233 other variables with the prefix java).
T227 0 u_Holger : @jaxad0127 main could have been defined to be a keyword|COMMA| it could still become a keyword|COMMA| just like _ stopped to be a legal identifier|COMMA| however|COMMA| it is not and this was a deliberate decision. The Java designers decided that|COMMA| e.g. goto and const are keywords|COMMA| to prevent their use as misleading identifiers|COMMA| but main does not require such special treatment.
T228 0 u_davidxxx : @AJPerez I completely agree. But well both are bad. You could notice that I added main as variable name but I didn't quote it in things that we don't want (not the hazard). But I will remove it to be consistent.
T233 0 u_serg : Looks nice and simple|COMMA| only I have feeling that shutdown here is used not for what it was designed (or it is fine?).
TW 0 u_cletus : It's a common pattern. Transient threadpools like the above are good for several reasons and I pretty much always prefer them to persistent threadpools where a lot more can go wrong or at least it can be harder to figure out. The above is really straightforward which is why I like it.
T233 0 u_matt_b : this is exactly what shutdown / awaitTermination are meant for
T231 0 u_sjlee : It is a good pattern if this task handling is a one-time event. If this is done repeatedly during the same runtime|COMMA| however|COMMA| it is not optimal|COMMA| as you would create and tear down threads repeatedly every time it is executed.
T235 0 u_è±¡å˜‰é“ : This pattern is incomplete: Some unsubmitted tasks may be never executed.
T235 0 u_inanutshellus : @Kejia It is not incomplete... Think about it this way: Your main thread is spawning off subthreads in a loop. When it's done adding|COMMA| you run this code. You might see output out of order|COMMA| but all of your tasks will have been spun off. Thanks @Cletus!
T230 0 u_Sam_Harwell : I'm looking for any official documentation that Long.MAX_VALUE|COMMA| TimeUnit.NANOSECONDS is equivalent to not having a timeout.
T236 0 u_Brad : @serg is this still considered the best answer over using invokeAll() as proposed by sjlee?
T232 0 u_rogerdpack : I can't believe that you have to use shutdown in order to join on all the current threads (after using shutdown|COMMA| you cannot use the executor again ever). Suggest using list of Future's instead...
TW 0 u_jontejj : As I'm testing this out I found that the executor finishes before all tasks have completed. If I use Thread.sleep(100) before calling shutdown() it works. So I suspect that there may be some timing issues with your code if the time between adding tasks to the shutdown call is too small.
TW 0 u_Nazgul : this wont work if you dont want to shutdown the executor. For a perpetually running batch kind of thing u need to submit jobs and wait for them to finish before jumping ahead. In Such a case a latch or a barrier makes more sense than a shutdown.
T234 0 u_gerrytan : IMO it's probably not a wise thing to NOT have a timeout. There's always a likelihood your task is stuck / deadlocking and the user would wait forever.
TW 0 u_Zero3 : @ashutosh I can't find any documentation on this. It appears to be a method of a Spring library|COMMA| and not plain Java functionality.
T230 0 u_ : @SamHarwell see the java.util.concurrent package documentation under the Timing section: To wait "forever"|COMMA| you can use a value of Long.MAX_VALUE
TW 0 u_ToolmakerSteve : @ashutosh 1) That requires springframework. 2) Doesn't look any simpler to me than shutdown/awaitTermination.
TW 0 u_Praveen_Kumar : Is it better than using infinite loop while checking isTerminated() ?
TW 0 u_Sergio_Bilello : If I don't want to shutdown because I want to keep my executor alive. How can I know the maximum number of pending tasks that could I have there?
T230 0 u_hinneLinks : @SamHarwell TimeUnit.NANOSECONDS and Long.MAX_VALUE equals 106|COMMA|751 Days or 292 years (TimeUnit.NANOSECONDS.toDays(Long.MAX_VALUE);)|COMMA| that should be enough|COMMA| or use some of the bigger TimeUnits.
TW 0 u_eli-bd : When sizing thread pools|COMMA| it is often useful to base the size on the number of logical cores in the machine running the application. In Java|COMMA| you can get that value by calling Runtime.getRuntime().availableProcessors(). In this case|COMMA| it would be Math.min(4|COMMA| Runtime.getRuntime().availableProcessors());
TW 0 u_Jobs : executor.shutdown(); is stopping my program !!
TW 0 u_Mobigital : Java apis are pretty terrible. Thank you for this insight.
TW 0 u_gaurav : @cletus is awaitTermination() necessary after shutdown()?
T238 0 u_Ulrich_Schmidt : Well|COMMA| this effectively means that any Function can always be used as a Consumer|COMMA| right? I wasn't aware of this design choice|COMMA| so thanks for pointing this out. Still|COMMA| why then are Function Lambdas like s -> s not allowed as Consumer arguments?
T238 0 u_Czyzby : Well|COMMA| there's always the Java typing issue|COMMA| so you can't pass a constructed Function as Consumer or cast/assign it to a Consumer variable. It still uses the same old Java typing mechanism - you can think of lambdas as anonymous classes|COMMA| except with prettier syntax and different internals. (I won't go into details|COMMA| but chances are that they do not compile into the same exact bytecode.) However|COMMA| any method that could construct a Function<A|COMMA| B> (that consumes type A)|COMMA| could be used to construct a Consumer<A>.
T238 0 u_Czyzby : About the s -> s - my guess is that if you explicitly define a new lambda without referencing an existing method|COMMA| you have to follow its exact method signature. In this case|COMMA| Consumer<String> does not return anything|COMMA| so you cannot just end the lambda with a line that basically stands for return s;. s -> s.toString() (which would pretty have the same result) should work|COMMA| as the method would be simply invoked and its result (s) would be ignored.
T238 0 u_Ulrich_Schmidt : It does work indeed! Amazing! s -> s triggers a compiler error "Void methods cannot return a value" but s -> s.toString() is accepted. I still don't understand the difference between these two Lambda expressions.
T238 0 u_Czyzby : s -> s is an equivalent of s -> { return s; }|COMMA| which fails to compile|COMMA| as Consumer method cannot return a value. s -> s.toString() might seem to "do" the same thing|COMMA| but it actually is an equivalent of s -> { s.toString(); }|COMMA| which simply invokes a method|COMMA| but does not return anything. So - in the first example|COMMA| you're trying to return a value. In the second|COMMA| you're actually invoking a method and ignoring its result.
T238 0 u_ : I think I understand it now :-) If the target type is a Consumer|COMMA| then s -> s.toString()is interpreted as s -> { s.toString(); }. If the target type is a Function|COMMA| then the same lambda is interpreted as s -> { return s.toString(); }
T238 0 u_Czyzby : Yes|COMMA| that's it. Is there anything you'd like me to add to the original answer or can it be accepted as it is?
T238 0 u_Ulrich_Schmidt : Your original answer is certainly acceptable in light of our discussion. Thanks again for your patience in explaining these things. Type inference does sometimes lead to suprising conclusions!
T237 0 u_Brian_Goetz : Here's the basis for this design decision: Java allows you to call a method and ignore the return value (a method invocation expression as a statement). Since we allow this at the invocation|COMMA| we also allow this when adapting a method to a functional interface whose arguments are compatible but the functional interface is void-returning.
T237 0 u_Brian_Goetz : Note also that we'll do other adaptations (boxing|COMMA| unboxing) to make the shape of the lambda match up with the expected shape of the functional interface. Ignoring a return value is just one of those adaptations.
T239 0 u_Hank_D : A convenient way to adapt a Function<T|COMMA|R> to a Consumer<T|COMMA|R> is to append ::apply to a Function instance; then the Function return type can be ignored like any other method that returns a value|COMMA| e.g. Function<String|COMMA|Integer> f = String::length; Consumer<String> c = f::apply;
T242 0 u_Martin : This has changed now. You can use Java 7 as well. As long as you don't use try with resources.
T240 0 u_Ben_Leggiero : Did Java 8 change the way the bytecode works? If not|COMMA| it should be fine to use any version of Java|COMMA| theoretically|COMMA| as long as it compiles.
T240 0 u_Eng._Samer_T : the correct question is: what if you use new features in java 8 not exists in java 7 to build android app|COMMA| is it ok? to be on safe side follow official instructions.
T240 0 u_ : @BenC.R.Leggiero there's no new bytecode in Java 8|COMMA| but the instructions' meanings and structures were changed stackoverflow.com/questions/28228450/â€¦ stackoverflow.com/questions/16143684/â€¦
TC 0 u_Aleksandr_Dubinsky : Please do not post "Update N" in your answer. Rewrite it to have up-to-date information. Otherwise|COMMA| SO will in a few years be as difficult to get information from as the forums it superseded.
TX 0 u_Neon_Warge : As I understand it|COMMA| It says Android N is supporting Java 8|COMMA| so it means APIs < Android N doesn't have it. Is this correct?
TX 0 u_ : Jack toolchain is now deprecated as per this announcement. Replacement is in the works.
T243 0 u_user239558 : This answer needs to be updated. The first sentence "I think it is too early to say if Java 8 is suitable for Android development" is completely outdated an links to old data. The "Updated" stuff is also very old.
T244 0 u_Guillaume_Husta : Not all Java 7 features are available in Android. Like the package java.nio.file. It will be available in Android O as I understand ?
T241 0 u_Ð®Ñ€Ñ–Ð¹_ÐœÐ°Ð·ÑƒÑ€ÐµÐ²Ð¸Ñ‡ : Answer need to be update. Java 8 will is supported as of Android Studio 3.0 and Gradle Plugin 3.0.
T245 0 u_Federico_Peralta_Schaffner : So maybe this should be reported as a bug?
T245 0 u_Holger : @FedericoPeraltaSchaffner I donâ€™t know whether the behavior matches the specification. I just used the word â€œflawâ€ from the practical point of view. I didnâ€™t have the time to check the specification yet and this part of the spec is one of toughestâ€¦
T245 0 u_JimmyB : I don't think it's a "flaw": Consumer<? super Supplier> would even match Consumer<Object>|COMMA| and Object is not a funtional interface. By downcasting to Supplier you make the potentially-Object an instance of a functional interface again.
T245 0 u_Holger : @JimmyB Consumer<? super Supplierâ€¦> could be a Consumer<Object>|COMMA| but you see at the action variable that the compiler does not assume Consumer<Object>|COMMA| as the lambda expression s -> System.out.println(s.get()) invokes the supplierâ€™s get method without problems. Here|COMMA| the compiler does assume the most specific type which is Consumer<Supplier<? extends String>>. And it could do the same for the invocation of accept. See the last example of my answer which doesnâ€™t have a type cast. These assignments are valid.
T245 0 u_JimmyB : @Holger No|COMMA| your last example does not have an explicit cast. But your supp is not of type ? super Supplier but of type Supplier which amounts to the same as the other example with an explicit cast. When using action its declared type is what matters to the compiler|COMMA| and that type does not guarantee that there's a supplier involved. In other words|COMMA| ? super Supplier means that consumer.accept(new Object()) would be valid w.r.t. generic types. Hence|COMMA| the compiler only knows that some object is required and fails to see how customer::getName should target the non
T245 0 u_ : functional interface type Object.
T245 0 u_JimmyB : By the way|COMMA| ? super X is meant to designate some kind of 'container' for objects of type X|COMMA| i.e. it is guaranteed that I can assign an instance of type X to a given variable (ensures assignability). In the case of the OP this is not needed because he won't be assigning anything to the given supplier reference inside his consumer.
T245 0 u_ : @JimmyB You can not do consumer.accept(new Object()). The declaration Consumer<? super Supplier<? extends String>> action implies that you can assign a Consumer<Object> to action|COMMA| because a Consumer<Object> can also handle Supplier<? extends String> arguments in its accept method. But since it is also possible to assign a Consumer<Supplier<? extends String>> to it|COMMA| as happening implicitly in my examples|COMMA| it would never be valid to pass new Object() to the accept method. The argument to accept must be assignable to Supplier<? extends String>. So why not infer thatâ€¦
T245 0 u_JimmyB : @Holger No|COMMA| the argument to accept must be a super type of Supplier. That's what ? super Supplier declares|COMMA| and that does not make sense in this case. Consumer<Supplier> declares what you intend|COMMA| making only instances of Supplier acceptable.
T245 0 u_Holger : @JimmyB: Apparently|COMMA| you are so convinced of yourself that you didnâ€™t even try it. Since you are only repeating yourself|COMMA| this pointless discussion has to stop here.
T245 0 u_JimmyB : @Holger While I do understand your point|COMMA| obviously the compiler proves both of us wrong: It does not in fact accept new Object() (although the effective declared method becomes accept(Object t))|COMMA| but on the other hand it does not infer the need for a Supplier (because the effective declared method becomes accept(Object t)).
T245 0 u_Holger : @JimmyB: There is no such thing as â€œeffective declared methodâ€. Apparently you are confusing this with type erasure|COMMA| but type erasure has nothing to do with what is valid under the generic type system. As said several times|COMMA| the signature Consumer<? super Type> implies that the accept method requires Type|COMMA| the relevant difference to Consumer<Type> is that the actual implementation may be a consumer of a super type. But in the example of the answer|COMMA| it is not. There|COMMA| it is a Consumer<Supplier<? extends String>>.
T245 0 u_JimmyB : @Holger Yes|COMMA| I am referring to type erasure. And through that|COMMA| Consumer<? super X> gets its accept() as accept(<? super X>) (itself not valid syntax)|COMMA| and that method should accept anything of X or a super type|COMMA| hence when typing eclipse offers me accept(Object t).
T245 0 u_JimmyB : @Holger I think|COMMA| together we can pin down the issue: You are correct in that Consumer<? super X> action says something about which kinds of consumers may be assigned to action; could be Constumer<Object> if one wants. Now|COMMA| if I assigned a Constumer<Object> to action at some point in my program|COMMA| action.accept(...) would accept Object which is not a functional interface. Thus|COMMA| from the declared type of action the compiler cannot infer that the actual instance is restricted to functional interfaces|COMMA| because it might not.
T245 0 u_JimmyB : Btw|COMMA| I just tried once more and my eclipse Neon actually only suggests accept(Supplier<...> t) while Oxygen on my laptop showed accept(Object t).
T245 0 u_Holger : @JimmyB there is no need for the target type to be â€œrestricted to functional interfacesâ€. See|COMMA| whenever there is a variable or parameter of type X|COMMA| X being a functional interface|COMMA| you could also assign Y|COMMA| a subtype of X not being a functional interface. The variable is never â€œrestricted to functional interfacesâ€. And once you have assigned the lambda expression to a variable or parameter of a functional interface type|COMMA| the receiving code could always assign that to a wider type like Object. All that matters is whether the compiler understands what to do before assigning the result.
T245 0 u_Holger : @JimmyB Regarding type erasure|COMMA| when you write|COMMA| e.g. Set<Runnable> l = Collections.singleton(() -> System.out.println("hello"));|COMMA| you are also passing the lambda expression to a method receiving Object under the cover|COMMA| as singleton accepts arbitrary types|COMMA| not even remotely restricted to lambda expression. Itâ€™s only our generic (compile-time) usage|COMMA| i.e. assigning to a Set<Runnable> (which will be just Set after erasure)|COMMA| which determines the lambdaâ€™s target type for the compiler.
T245 0 u_JimmyB : @Holger Not sure I get your point. If X is a functional interface|COMMA| then Y extending X should implicitly be a functional interface too. So whatever I can do on a functional interface X|COMMA| I can do on Y too.
T245 0 u_ : Supplier<String> s = obj::toString; works|COMMA| Object o = obj::toString; doesn't.